package uk.whitecrescent.waqti.code

import io.reactivex.Observable
import java.time.Duration
import java.time.LocalDateTime

class Task(var title: String) {

    //region Class Properties

    /**
     * The Task State is the state in which the task is in at this point in time.
     * By default this is set to EXISTING.
     * See The Task Lifecycle Documentation for more information
     * @see TaskState
     */
    private var state = DEFAULT_TASK_STATE

    /**
     * Boolean value representing whether it is possible for this Task to be failed at any arbitrary point in time.
     * Note that this is not the same as whether it can be failed right now, however if a Task's `isFailable`
     * is `false` then it can not be failed at this point in time.
     * @see TaskState
     * @see Constraint
     */
    var isFailable = false

    /**
     * Boolean value representing whether it is possible for this Task to be killed at any arbitrary point in time.
     * Note that this is not the same as whether it can be killed right now, however if a Task's `isKillable`
     * is `false` then it can not be killed at this point in time.
     * @see TaskState
     */
    var isKillable = true

    /**
     * A Long value representing an ID for a Task.
     * Every Task has a unique identifier which is generated by means of pseudo-random number designation.
     * No 2 Tasks can have the same taskID, all taskIDs are positive Long values generated randomly.
     * The list of all currently used IDs should be stored persistently.
     * @see GSON.newID
     * @see java.util.Random.nextLong
     */
    var taskID = GSON.newID()

    // A Task ages when it is failed
    var age = 0

    // The time a task is failed
    var failedTime = Time.MIN

    // The time a task is killed
    var killedTime = Time.MIN

    //endregion

    //region Task Properties

    var time: Property<Time> = DEFAULT_TIME_PROPERTY
        private set(time) {
            field = time
        }

    var duration: Property<Duration> = DEFAULT_DURATION_PROPERTY
        private set(duration) {
            field = duration
        }

    var priority: Property<Priority> = DEFAULT_PRIORITY_PROPERTY
        private set(priority) {
            field = priority
        }

    //TODO this should be many labels, not 1 ! So an ArrayList of Labels
    var label: Property<Label> = DEFAULT_LABEL_PROPERTY
        private set(label) {
            field = label
        }

    var optional: Property<Optional> = DEFAULT_OPTIONAL_PROPERTY
        private set(optional) {
            field = optional
        }

    var description: Property<Description> = DEFAULT_DESCRIPTION_PROPERTY
        private set(description) {
            field = description
        }

    var checklist: Property<Checklist> = DEFAULT_CHECKLIST_PROPERTY
        private set(checklist) {
            field = checklist
        }

    var deadline: Property<Time> = DEFAULT_DEADLINE_PROPERTY
        private set(deadline) {
            field = deadline
        }

    var target: Property<String> = DEFAULT_TARGET_PROPERTY
        private set(target) {
            field = target
        }

    // The Task before this
    var before: Property<TaskID> = DEFAULT_BEFORE_PROPERTY
        private set(before) {
            field = before
        }

    // The Task after this
    var after: Property<TaskID> = DEFAULT_AFTER_PROPERTY
        private set(after) {
            field = after
        }

    //TODO Implement this guy everywhere please but define him in the .md
    var subTasks: Property<ArrayList<TaskID>> = DEFAULT_SUB_TASKS_PROPERTY
        private set(subTasks) {
            field = subTasks
        }


    //endregion

    //region Task Properties Functions

    private fun makeFailableIfConstraint(property: Property<*>) {
        if (!this.isFailable && property is Constraint) {
            this.isFailable = true
        }
    }

    private fun getAllProperties() = listOf(
            time,
            duration,
            priority,
            label,
            optional,
            description,
            checklist,
            deadline,
            target,
            before,
            after
    )

    private fun getAllConstraints() = getAllProperties().filter { it is Constraint }

    fun getAllShowingProperties() =
            getAllProperties().filter { it.isVisible }

    fun getAllShowingConstraints() =
            getAllConstraints().filter { it.isVisible }

    fun getAllUnmetAndShowingConstraints() =
            getAllConstraints().filter { !(it as Constraint).isMet && it.isVisible }

    private fun isNotConstraint(property: Property<*>) = property !is Constraint

    //endregion

    //region Property setters for chaining

    fun setTimeProperty(timeProperty: Property<LocalDateTime>): Task {
        this.time = timeProperty
        makeFailableIfConstraint(timeProperty)
        if (timeProperty.value.isAfter(now())) {
            this.state = TaskState.SLEEPING
            concurrentStateCheckingForTime()
        }
        return this
    }

    fun setTimeConstraint(timeConstraint: Constraint<LocalDateTime>): Task {
        return setTimeProperty(timeConstraint)
    }

    fun setTimeValue(time: LocalDateTime): Task {
        return setTimeProperty(Property(SHOWING, time))
    }

    fun setDurationProperty(durationProperty: Property<Duration>): Task {
        this.duration = durationProperty
        makeFailableIfConstraint(durationProperty)
        return this
    }

    fun setDurationConstraint(durationConstraint: Constraint<Duration>): Task {
        return setDurationProperty(durationConstraint)
    }

    fun setDurationValue(duration: Duration): Task {
        return setDurationProperty(Property(SHOWING, duration))
    }

    fun setPriorityProperty(priorityProperty: Property<Priority>): Task {
        this.priority = priorityProperty
        makeFailableIfConstraint(priorityProperty)
        return this
    }

    fun setPriorityConstraint(priorityConstraint: Constraint<Priority>): Task {
        return setPriorityProperty(priorityConstraint)
    }

    fun setPriorityValue(priority: Priority): Task {
        return setPriorityProperty(Property(SHOWING, priority))
    }

    fun setLabelProperty(labelProperty: Property<Label>): Task {
        this.label = labelProperty
        makeFailableIfConstraint(labelProperty)
        return this
    }

    fun setLabelConstraint(labelConstraint: Constraint<Label>): Task {
        return setLabelProperty(labelConstraint)
    }

    fun setLabelValue(label: Label): Task {
        return setLabelProperty(Property(SHOWING, label))
    }

    fun setOptionalProperty(optionalProperty: Property<Boolean>): Task {
        this.optional = optionalProperty
        makeFailableIfConstraint(optionalProperty)
        return this
    }

    fun setOptionalConstraint(optionalConstraint: Constraint<Boolean>): Task {
        return setOptionalProperty(optionalConstraint)
    }

    fun setOptionalValue(optional: Boolean): Task {
        return setOptionalProperty(Property(SHOWING, optional))
    }

    fun setDescriptionProperty(descriptionProperty: Property<StringBuilder>): Task {
        this.description = descriptionProperty
        makeFailableIfConstraint(descriptionProperty)
        return this
    }

    fun setDescriptionConstraint(descriptionConstraint: Constraint<StringBuilder>): Task {
        return setDescriptionProperty(descriptionConstraint)
    }

    fun setDescriptionValue(description: StringBuilder): Task {
        return setDescriptionProperty(Property(SHOWING, description))
    }

    fun setChecklistProperty(checklistProperty: Property<Checklist>): Task {
        this.checklist = checklistProperty
        makeFailableIfConstraint(checklistProperty)
        return this
    }

    fun setChecklistConstraint(checklistConstraint: Constraint<Checklist>): Task {
        return setChecklistProperty(checklistConstraint)
    }

    fun setChecklistValue(checklist: Checklist): Task {
        return setChecklistProperty(Property(SHOWING, checklist))

    }

    fun setDeadlineProperty(deadlineProperty: Property<LocalDateTime>): Task {
        this.deadline = deadlineProperty
        if (deadlineProperty is Constraint) {
            concurrentTimeCheckingForDeadlineConstraint()
        }
        makeFailableIfConstraint(deadlineProperty)
        return this
    }

    fun setDeadlineConstraint(deadlineConstraint: Constraint<LocalDateTime>): Task {
        return setDeadlineProperty(deadlineConstraint)
    }

    fun setDeadlineValue(deadline: LocalDateTime): Task {
        return setDeadlineProperty(Property(SHOWING, deadline))
    }

    fun setTargetProperty(targetProperty: Property<String>): Task {
        this.target = targetProperty
        makeFailableIfConstraint(targetProperty)
        return this
    }

    fun setTargetConstraint(targetConstraint: Constraint<String>): Task {
        return setTargetProperty(targetConstraint)
    }

    fun setTargetValue(target: String): Task {
        return setTargetProperty(Property(SHOWING, target))
    }

    fun setBeforeProperty(beforeProperty: Property<Long>): Task {
        this.before = beforeProperty
        makeFailableIfConstraint(beforeProperty)
        return this
    }

    fun setBeforeProperty(beforeTask: Task): Task {
        return setBeforeProperty(Property(SHOWING, beforeTask.taskID))
    }

    fun setBeforeConstraint(beforeConstraint: Constraint<Long>): Task {
        return setBeforeProperty(beforeConstraint)
    }

    fun setBeforeConstraint(beforeTask: Task): Task {
        return setBeforeProperty(Constraint(SHOWING, beforeTask.taskID, UNMET))
    }

    fun setBeforeValue(before: Long): Task {
        return setBeforeProperty(Property(SHOWING, before))
    }

    fun setAfterProperty(afterProperty: Property<Long>): Task {
        this.after = afterProperty
        makeFailableIfConstraint(afterProperty)
        return this
    }

    fun setAfterProperty(afterTask: Task): Task {
        return setAfterProperty(Property(SHOWING, afterTask.taskID))
    }

    fun setAfterConstraint(afterConstraint: Constraint<Long>): Task {
        return setAfterProperty(afterConstraint)
    }

    fun setAfterConstraint(afterTask: Task): Task {
        return setAfterProperty(Constraint(SHOWING, afterTask.taskID, UNMET))
    }

    fun setAfterValue(after: Long): Task {
        return setAfterProperty(Property(SHOWING, after))
    }

    //endregion

    //region Hide Properties

    fun hideTime() {
        if (isNotConstraint(time)) {
            time = DEFAULT_TIME_PROPERTY
        } else throw IllegalStateException("Cannot hide, time is Constraint")
    }

    fun hideDuration() {
        if (isNotConstraint(duration)) {
            duration = DEFAULT_DURATION_PROPERTY
        } else throw IllegalStateException("Cannot hide, duration is Constraint")
    }

    fun hidePriority() {
        if (isNotConstraint(priority)) {
            priority = DEFAULT_PRIORITY_PROPERTY
        } else throw IllegalStateException("Cannot hide, priority is Constraint")
    }

    fun hideLabel() {
        if (isNotConstraint(label)) {
            label = DEFAULT_LABEL_PROPERTY
        } else throw IllegalStateException("Cannot hide, label is Constraint")
    }

    fun hideOptional() {
        if (isNotConstraint(optional)) {
            optional = DEFAULT_OPTIONAL_PROPERTY
        } else throw IllegalStateException("Cannot hide, optional is Constraint")
    }

    fun hideDescription() {
        if (isNotConstraint(description)) {
            description = DEFAULT_DESCRIPTION_PROPERTY
        } else throw IllegalStateException("Cannot hide, description is Constraint")
    }

    fun hideChecklist() {
        if (isNotConstraint(checklist)) {
            checklist = DEFAULT_CHECKLIST_PROPERTY
        } else throw IllegalStateException("Cannot hide, checklist is Constraint")
    }

    fun hideDeadline() {
        if (isNotConstraint(deadline)) {
            deadline = DEFAULT_DEADLINE_PROPERTY
        } else throw IllegalStateException("Cannot hide, deadline is Constraint")
    }

    fun hideTarget() {
        if (isNotConstraint(target)) {
            target = DEFAULT_TARGET_PROPERTY
        } else throw IllegalStateException("Cannot hide, target is Constraint")
    }

    fun hideBefore() {
        if (isNotConstraint(before)) {
            before = DEFAULT_BEFORE_PROPERTY
        } else throw IllegalStateException("Cannot hide, before is Constraint")
    }

    fun hideAfter() {
        if (isNotConstraint(after)) {
            after = DEFAULT_AFTER_PROPERTY
        } else throw IllegalStateException("Cannot hide, after is Constraint")
    }

    //endregion

    //region Task lifecycle

    fun getTaskState() = state

    private fun isExisting() = state == TaskState.EXISTING

    fun canKill() = isKillable &&
            isExisting() &&
            getAllUnmetAndShowingConstraints().isEmpty()


    fun canFail() = isFailable &&
            isExisting()

    fun canSleep() = getTaskState() == TaskState.FAILED

    fun fail() {
        if (state == TaskState.FAILED) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is already Failed!", getTaskState())
        }
        if (!isFailable) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is not Failable", getTaskState())
        } else if (canFail()) {
            state = TaskState.FAILED
            age++
            failedTime = now()
        } else {
            throw TaskStateException("Fail unsuccessful, unknown reason, remember only EXISTING tasks can be failed!", getTaskState())
        }
    }

    fun sleep() {
        if (state == TaskState.SLEEPING) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is already Sleeping!", getTaskState())
        }
        if (state == TaskState.KILLED) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is Killed!", getTaskState())
        }
        if (state == TaskState.EXISTING) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is Existing!", getTaskState())
        } else if (canSleep()) {
            state = TaskState.SLEEPING
        } else {
            throw TaskStateException("Sleep unsuccessful, unknown reason, remember only FAILED tasks can be slept!", getTaskState())
        }
    }

    // Send this tasks info to create a template from it
    fun sendToTemplate() {

    }


    // If a Task is killed it can be modified because it doesn't matter at all, after killed there is no other State.
    //TODO This isn't entirely true! We need to do something to make sure that Killed Tasks can't be meddled with much
    fun kill() {
        if (state == TaskState.KILLED) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is already Killed!", getTaskState())
        }
        if (!isKillable) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is not Killable", getTaskState())
        }
        if (!getAllUnmetAndShowingConstraints().isEmpty()) {
            throw TaskStateException("Kill unsuccessful, ${this.title} has unmet Constraints", getTaskState())
        } else if (canKill()) {
            state = TaskState.KILLED
            killedTime = now()
        } else {
            throw TaskStateException("Kill unsuccessful, unknown reason, remember only EXISTING tasks can be killed!", getTaskState())
        }
    }

    //endregion

    //region Concurrency

    // This is both computationally cheap and terminates
    private fun concurrentStateCheckingForTime() {

        /*
         * Runs every 1 second as long as this state is SLEEPING
         * And every 1 second it will compare the time now to the scheduled time and if
         * the scheduled time has passed, will change the state to EXISTING, thus ending the session and completing
         */
        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { this.state == TaskState.SLEEPING }
                .subscribeOn(Concurrent.stateCheckingThread)
                .subscribe(
                        {
                            if (this.time.value.isAfter(now())) {
                                this.state = TaskState.EXISTING
                            }
                        },
                        {
                            logE("Concurrent state checking for time failed!")
                            it.printStackTrace()
                        },
                        {
                            logI("Concurrent state checking for time completed!")
                        },
                        {
                            logI("Concurrent state checking for time started")
                        }
                )
    }

    private fun concurrentTimeCheckingForDeadlineConstraint() {

        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { this.deadline.value.plusSeconds(1).isAfter(now()) }
                .subscribeOn(Concurrent.timeCheckingThread)
                .subscribe(
                        {
                            if (now().isAfter(this.deadline.value)) {
                                this.fail()
                            }
                        },
                        {
                            logE("Concurrent time checking for deadline failed!")
                            it.printStackTrace()
                        },
                        {
                            logI("Concurrent time checking for deadline completed!")
                        },
                        {
                            logI("Concurrent time checking for deadline started")
                        }
                )

    }

    //endregion

    //region Persistence Utilities

    fun saveToJSON(): Task {
        GSON.saveTask(this)
        return this
    }

    companion object {
        // Used by JSON only to create Tasks in memory from the database, does not write them to database, since
        // they're already written in the database
        fun createTaskFromJSON(state: TaskState,
                               isFailable: Boolean,
                               isKillable: Boolean,
                               taskID: Long,
                               time: Property<LocalDateTime>,
                               duration: Property<Duration>,
                               priority: Property<Priority>,
                               label: Property<Label>,
                               optional: Property<Boolean>,
                               description: Property<StringBuilder>,
                               checklist: Property<Checklist>,
                               deadline: Property<LocalDateTime>,
                               target: Property<String>,
                               before: Property<Long>,
                               after: Property<Long>,
                               title: String
        ) = Task(state, isFailable, isKillable, taskID, time,
                duration, priority, label, optional, description,
                checklist, deadline, target, before, after, title)

    }


    private constructor(
            state: TaskState,
            isFailable: Boolean,
            isKillable: Boolean,
            taskID: Long,
            time: Property<LocalDateTime>,
            duration: Property<Duration>,
            priority: Property<Priority>,
            label: Property<Label>,
            optional: Property<Boolean>,
            description: Property<StringBuilder>,
            checklist: Property<Checklist>,
            deadline: Property<LocalDateTime>,
            target: Property<String>,
            before: Property<Long>,
            after: Property<Long>,
            title: String
    ) : this(title) {
        this.state = state
        this.isFailable = isFailable
        this.isKillable = isKillable
        this.taskID = taskID
        this.time = time
        this.duration = duration
        this.priority = priority
        this.label = label
        this.optional = optional
        this.description = description
        this.checklist = checklist
        this.deadline = deadline
        this.target = target
        this.before = before
        this.after = after

    }

    //endregion

    //region Overriden from kotlin.Any

    override fun hashCode() =
            title.hashCode() + getAllShowingProperties().hashCode()

    override fun equals(other: Any?) =
            other is Task &&
                    other.title.equals(this.title) &&
                    other.getTaskState().equals(this.state) &&
                    other.getAllShowingProperties().equals(this.getAllShowingProperties())

    override fun toString(): String {
        val result = StringBuilder("$title\n")
        result.append("ID: ${this.taskID} isKillable: ${isKillable} isFailable: ${isFailable} state: ${state}\n")

        result.append("\tP:\n")

        getAllShowingProperties().filter { it !is Constraint }.forEach { result.append("\t\t$it\n") }

        result.append("\tC:\n")

        getAllShowingConstraints().forEach { result.append("\t\t$it\n") }

        return result.toString()
    }

    //endregion
}


