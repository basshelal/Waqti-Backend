package uk.whitecrescent.waqti.code

import io.reactivex.Observable
import java.time.Duration
import java.time.LocalDateTime
import java.util.Random

//TODO make sure KDoc is up to date
class Task(var title: String) {

    //region Class Properties

    /**
     * The Task State is the state in which the task is in at this point in time.
     * By default this is set to EXISTING.
     * See The Task Lifecycle Documentation for more information
     * @see TaskState
     */
    private var state = DEFAULT_TASK_STATE

    /**
     * Boolean value representing whether it is possible for this Task to be failed at any arbitrary point in time.
     * Note that this is not the same as whether it can be failed right now, however if a Task's `isFailable`
     * is `false` then it can not be failed at this point in time.
     * @see TaskState
     * @see Constraint
     */
    var isFailable = DEFAULT_FAILABLE

    /**
     * Boolean value representing whether it is possible for this Task to be killed at any arbitrary point in time.
     * Note that this is not the same as whether it can be killed right now, however if a Task's `isKillable`
     * is `false` then it can not be killed at this point in time.
     * @see TaskState
     */
    var isKillable = DEFAULT_KILLABLE

    /**
     * A Long value representing an ID for a Task.
     * Every Task has a unique identifier which is generated by means of pseudo-random number designation.
     * No 2 Tasks can have the same taskID, all taskIDs are positive Long values generated randomly.
     * The list of all currently used IDs should be stored persistently.
     * @see java.util.Random.nextLong
     */
    var taskID = Math.abs(Random().nextLong())

    /**
     * The point in time at which the duration Property was set, used to calculate duration left by adding the
     * duration set to the time it was set to get the time it is due and then getting the duration between now and
     * the time it is due. This means that duration left is calculated when requested and not ongoing as the duration
     * decreases.
     */
    private var timeDurationSet = DEFAULT_TIME

    // A Task ages when it is failed
    var age = 0
        private set(age) {
            field = age
        }

    // The times a task has been failed
    var failedTimes = arrayListOf<Time>()
        private set(failedTimes) {
            field = failedTimes
        }

    // The time a task is killed
    var killedTime = DEFAULT_TIME
        private set(killedTime) {
            field = killedTime
        }

    // Put this in the Database and make sure this' key is unique
    init {
        while (DATABASE.containsKey(this.taskID)) {
            this.taskID = Math.abs(Random().nextLong())
        }
        DATABASE.put(this.taskID, this)
    }

    /**
     * Used to determine the overall state of this Task at this point in time.
     *
     * This is especially useful for [Task.hashCode] and [Task.equals] hence the implementation does not contain as
     * many aspects of this Task as it could.
     *
     * A Task's Equality Bundle is determined by the following:
     *
     * * [title]
     * * [state]
     * * [isFailable]
     * * [isKillable]
     * * [age]
     * * [failedTimes]
     * * [killedTime]
     * * [getAllProperties], the list of this Task's Properties.
     *
     * For [getAllProperties] see [java.util.ArrayList.equals], essentially all Properties must be equal in order for
     * this to be satisfied see [Property.equals] meaning even the values must be equal, this will differ depending
     * on the type of value, for example any [LocalDateTime] is equal to another if and only if they are exactly the
     * same to the nanosecond precision see [LocalDateTime.equals] whereas [StringBuilder] checks for equality using
     * identity meaning two different StringBuilder instances can have the exact same value and be consider unequal
     * see [java.lang.StringBuilder] (it does not override equals, hence this default implementation)
     *
     * @see HashMap
     * @return a HashMap with `String` as the Key and `Any` as the Value to represent the Equality Bundle which will
     * store the parts that make up a Task's overall state
     */
    private fun equalityBundle(): Bundle<String, Any> {
        val bundle = HashMap<String, Any>(20)
        bundle["title"] = this.title
        bundle["state"] = this.state
        bundle["isFailable"] = this.isFailable
        bundle["isKillable"] = this.isKillable
        bundle["age"] = this.age
        bundle["failedTimes"] = this.failedTimes
        bundle["killedTime"] = this.killedTime
        bundle["properties"] = this.getAllProperties()
        return bundle
    }

    //endregion Class Properties

    //region Task Properties

    /**
     * The point in natural time after which this Task will be relevant, this can also be referred to as scheduled
     * time.
     *
     * If time is a Constraint then the Task cannot be killed until after that time
     * and is in the SLEEPING state during that period, however, if time is not a Constraint then the Task can be
     * killed freely and will be in its previous state meaning no lifecycle change will be made. If time is a
     * Property then it has no rules on killing the Task.
     *
     * @see LocalDateTime
     */
    var time: Property<Time> = DEFAULT_TIME_PROPERTY
        private set(time) {
            field = time
        }

    /**
     * The estimated amount of time that this Task will take, this can also be referred to as minimum duration.
     *
     * This is defined in any Time Measurement Unit, either as a standard Time Unit such as seconds or days etc or
     * custom Time Units [TimeUnit]. This can also be referred to as minimum duration. If duration is a Constraint
     * then the Task cannot be killed in the midst of the duration, it can be killed only after it has ended. If
     * duration is a Property then it has no rules on killing the Task.
     *
     * @see Duration
     * @see TimeUnit
     */
    var duration: Property<Duration> = DEFAULT_DURATION_PROPERTY
        private set(duration) {
            field = duration
        }

    /**
     * The user defined level of importance of a Task represented as a String with a number representing importance
     * level.
     *
     * Priority is particularly useful in solving or mediating Task collisions within collections. A Task collision
     * occurs when two or more Tasks in a collection share the same time, if they have different priority levels then
     * the Task with the higher priority level will be shown and a collision warning will be displayed to the user,
     * this is called a weak collision. If the tasks have equal priority levels then the user must mediate or solve
     * the collision themselves, this is called a strong collision.
     *
     * Priority can not be a Constraint.
     *
     * @see Priority
     */
    var priority: Property<Priority> = DEFAULT_PRIORITY_PROPERTY
        private set(priority) {
            field = priority
        }

    /**
     * The user defined category(s) that this Task belongs to.
     *
     * A Task can belong to or have 0 or many labels. Labels are used as a way of categorizing Tasks and are thus
     * helpful in filtering and analytics.
     *
     * Labels can not be a Constraint.
     *
     * @see ArrayList
     * @see Label
     */
    var labels: Property<ArrayList<Label>> = DEFAULT_LABELS_PROPERTY
        private set(label) {
            field = label
        }

    /**
     * Shows whether the Task is optional or not.
     *
     * An optional Task is one that is to be done or pursued if there is free time, thus an optional Task has less
     * priority than a non-optional Task (mandatory Task) even if the Task has the lowest priority, this makes
     * optional Tasks the lowest priority of all Tasks. In many ways the optional Property acts similar to the priority
     * Property except in that optional is lower priority than the lowest priority.
     *
     * Optional can not be a Constraint.
     *
     * @see Boolean
     */
    var optional: Property<Optional> = DEFAULT_OPTIONAL_PROPERTY
        private set(optional) {
            field = optional
        }

    /**
     * A textual description of this Task, useful for if the Task is complex or requires further information that the
     * title cannot provide.
     *
     * Description can not be a Constraint.
     *
     * @see StringBuilder
     */
    var description: Property<Description> = DEFAULT_DESCRIPTION_PROPERTY
        private set(description) {
            field = description
        }

    /**
     * A list of checkable items that this Task may have.
     *
     * This is useful if the Task can be broken down into smaller chunks which can be represented as list items in a
     * checklist. Items in a checklist can be checked or deleted.
     *
     * If a checklist is a Constraint then the Task cannot be killed unless every item in the checklist is checked,
     * more specifically the checklist has no unchecked items. An empty checklist has no unchecked items so it is
     * important that the implementation be aware of this and differentiate between an empty checklist (which is
     * possible for good reasons) and a checklist with all its items checked.
     *
     * If checklist is a Property then it has no rules on killing the Task.
     *
     * @see Checklist
     * @see ListItem
     */
    var checklist: Property<Checklist> = DEFAULT_CHECKLIST_PROPERTY
        private set(checklist) {
            field = checklist
        }

    /**
     * The point in natural time after which this Task can no longer be killed and thus is FAILED.
     *
     * If deadline is a Constraint then after the deadline time passes plus the grace period [GRACE_PERIOD] the Task will be
     * FAILED and thus no longer can be KILLED.
     *
     * If deadline is a Property it has no rules on failing or killing the Task.
     *
     * @see LocalDateTime
     * @see GRACE_PERIOD
     */
    var deadline: Property<Time> = DEFAULT_DEADLINE_PROPERTY
        private set(deadline) {
            field = deadline
        }

    /**
     * The user defined textual representation of a desirable target to be achieved by the user before killing this
     * Task.
     *
     * If target is a Constraint then the Task cannot be killed unless the Target is checked. If target is a Property
     * then it has no rules on killing the Task and acts very similar to a description.
     *
     * @see String
     */
    var target: Property<Target> = DEFAULT_TARGET_PROPERTY
        private set(target) {
            field = target
        }

    /**
     * The Task that occurs before this Task.
     *
     * If before is a Constraint then this Task cannot be killed unless the before Task is killed, and if the before
     * Task is FAILED then this Task will also be FAILED if it can be since this Task will have a dependence on the
     * state of the before Task.
     *
     * If before is a Property then it has no rules on killing or failing the Task, it will just be a description of
     * the Task that comes before this one, good for ordering Tasks but not enforcing any ordering of completion.
     *
     * @see Long
     */
    var before: Property<TaskID> = DEFAULT_BEFORE_PROPERTY
        private set(before) {
            field = before
        }

    /**
     * The list of sub-Tasks this Task has, a Task can have zero to potentially many sub-Tasks but has zero by
     * default.
     *
     * If SubTasks is a Constraint then the state of the sub-Tasks is shared upwards to the parent, meaning
     * if this Task's sub-Tasks contains a FAILED Task then this Task is FAILED, if this Task's sub-Tasks contains a
     * non-killed non-optional Task then this Task cannot be killed, only if all the sub-Tasks are KILLED will the
     * Constraint be met.
     *
     * If SubTasks is a Property then it has no rules on killing or failing the Task, the sub-Tasks' states will make
     * no difference to this Task.
     *
     * @see ArrayList
     * @see Long
     */
    var subTasks: Property<ArrayList<TaskID>> = DEFAULT_SUB_TASKS_PROPERTY
        private set(subTasks) {
            field = subTasks
        }

    //endregion Task Properties

    //region Task Properties Functions

    /**
     * Makes this Task failable if the passed in Property is a Constraint and this Task is not currently failable.
     * @see Property
     * @see Constraint
     * @see isFailable
     * @param property the Property to check for if it is a Constraint
     */
    private fun makeFailableIfConstraint(property: Property<*>) {
        if (!this.isFailable && property is Constraint) {
            this.isFailable = true
        }
    }

    private fun makeNonFailableIfNoConstraints() {
        if (this.getAllConstraints().isEmpty()) this.isFailable = false
    }

    /**
     * Gets the list of all the Properties of a Task, does not matter what their values are.
     * See the Properties.md docs for more.
     * @return the list of all the Properties of a Task.
     */
    private fun getAllProperties() = listOf(
            time,
            duration,
            priority,
            labels,
            optional,
            description,
            checklist,
            deadline,
            target,
            before,
            subTasks
    )

    /**
     * Gets the list of all Constraints of this Task, does not matter what their values are as long as they are
     * Constraints.
     * @return the list of all current Constraints of this Task
     */
    private fun getAllConstraints() =
            getAllProperties().filter { it is Constraint }

    /**
     * Gets the list of all Properties of this Task that are showing. These would usually be the Properties of
     * interest.
     * @see Property
     * @return the list of all showing Properties this Task has
     */
    fun getAllShowingProperties() =
            getAllProperties().filter { it.isVisible }

    /**
     * Gets the list of all Constraints of this Task that are showing. The `isMet` value of the Constraints is ignored.
     * @see Constraint
     * @return the list of all showing Constraints this Task has
     */
    fun getAllShowingConstraints() =
            getAllConstraints().filter { it.isVisible }

    /**
     * Gets the list of all Constraints of this Task that are showing and also unmet. These would usually be the
     * Constraints of interest and the Constraints that would prevent a Task from being killed.
     * A Task can only be killed if this list is empty.
     * @see Constraint
     * @see canKill
     * @see kill
     * @return the list of all showing and unmet Constraints this Task has
     */
    fun getAllUnmetAndShowingConstraints() =
            getAllConstraints().filter { !(it as Constraint).isMet && it.isVisible }

    /**
     * Checks whether the passed in Property is a Constraint or not.
     * @see Property
     * @see Constraint
     * @param property the property to check whether it is a Constraint or not
     * @return true if the Property is a Constraints and false otherwise
     */
    private fun isNotConstraint(property: Property<*>) = property !is Constraint

    //endregion Task Properties Functions

    //region Property setters for chaining

    /**
     * Sets this Task's time Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `timeProperty` is after now and it is a Constraint, otherwise
     * no more changes will occur.
     *
     * In the case that the passed in `timeProperty` is a Constraint and it is after now, three things will happen:
     *
     * * This Task's state will become SLEEPING
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the time, and will become EXISTING once the time in `timeProperty` has passed
     * and will also make the time Constraint MET if it wasn't already see [timeConstraintTimeChecking]
     *
     * If the passed in `timeProperty` is not a Constraint or is not after now then the Task's state will remain the
     * same.
     *
     * @see Task.timeConstraintTimeChecking
     * @param timeProperty the `Property` of type `Time` that this Task's time will be set to
     * @return this Task after setting the Task's time Property
     */
    fun setTimeProperty(timeProperty: Property<Time>): Task {
        this.time = timeProperty
        if (timeProperty.value.isAfter(now()) && timeProperty is Constraint) {
            this.state = TaskState.SLEEPING
            makeFailableIfConstraint(timeProperty)
            timeConstraintTimeChecking()
        }
        return this
    }

    /**
     * Sets this Task's time Constraint.
     *
     * @see Task.setTimeProperty
     * @param timeConstraint the `Constraint` of type `Time` that this Task's time will be set to
     * @return this Task after setting the Task's time Constraint
     */
    fun setTimeConstraint(timeConstraint: Constraint<Time>): Task {
        return setTimeProperty(timeConstraint)
    }

    /**
     * Sets this Task's time Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setTimeProperty(Property(SHOWING, myTime))`.
     *
     * @see Task.setTimeProperty
     * @param time the Time value that this Task's time value will be set to
     * @return this Task after setting the Task's time Property
     */
    fun setTimePropertyValue(time: Time): Task {
        return setTimeProperty(Property(SHOWING, time))
    }

    /**
     * Sets this Task's time Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setTimeConstraint(Constraint(SHOWING, myTime, UNMET))`.
     *
     * @see Task.setTimeProperty
     * @param time the Time value that this Task's time value will be set to
     * @return this Task after setting the Task's time Constraint
     */
    fun setTimeConstraintValue(time: Time): Task {
        return setTimeProperty(Constraint(SHOWING, time, UNMET))
    }

    /**
     * Sets this Task's duration Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `durationProperty` is a Constraint.
     *
     * In the case that the passed in `durationProperty` is a Constraint, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the time and after the duration has passed will make the duration
     * Constraint MET if it wasn't already see [durationConstraintTimeChecking]
     *
     * If the passed in `durationProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.durationConstraintTimeChecking
     * @param durationProperty the `Property` of type `java.time.Duration` that this Task's duration will be set to
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationProperty(durationProperty: Property<Duration>): Task {
        this.duration = durationProperty
        timeDurationSet = now()
        if (durationProperty is Constraint) {
            makeFailableIfConstraint(durationProperty)
            durationConstraintTimeChecking()
        }
        return this
    }

    /**
     * Gets this Task's duration left until the duration Constraint will be met.
     *
     * This is not necessarily only used for Constraints but is more useful for when duration is a Constraint, since
     * this will return the difference in time between now and the time the duration is due to finish, this does not
     * require duration to be a Constraint but is of not much interest if duration is not a Constraint.
     *
     * @return the Duration left until this Task's duration Constraint is met
     * @throws IllegalStateException if the Duration has not been set
     */
    fun getDurationLeft(): Duration {
        if (duration.value == DEFAULT_DURATION) {
            throw IllegalStateException("Duration not set!")
        } else {
            val timeDue = timeDurationSet.plus(duration.value)
            return Duration.between(now(), timeDue)
        }
    }

    /**
     * Sets this Task's duration Constraint.
     *
     * @see Task.setDurationProperty
     * @param durationConstraint the `Constraint` of type `java.time.Duration` that this Task's duration will be set to
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraint(durationConstraint: Constraint<Duration>): Task {
        return setDurationProperty(durationConstraint)
    }

    /**
     * Sets this Task's duration Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDurationProperty(Property(SHOWING, myDuration))`.
     *
     * @see Task.setDurationProperty
     * @param duration the java.time.Duration value that this Task's duration value will be set to
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyValue(duration: Duration): Task {
        return setDurationProperty(Property(SHOWING, duration))
    }

    /**
     * Sets this Task's duration Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setDurationConstraint(Constraint(SHOWING, myDuration, UNMET))`.
     *
     * @see Task.setDurationProperty
     * @param duration the java.time.Duration value that this Task's duration value will be set to
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintValue(duration: Duration): Task {
        return setDurationProperty(Constraint(SHOWING, duration, UNMET))
    }

    /**
     * Sets this Task's duration Property with the duration of the TimeUnit multiplied by the `count` as the Property's
     * value and the `timeUnitProperty`'s `isVisible` value
     *
     * This allows to use Custom Time Units for setting the duration.
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnitProperty the Property of type `TimeUnit` that will be used to set this Task's duration
     * Property's visibility to and set the value to by multiplying by the `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyTimeUnits(timeUnitProperty: Property<TimeUnit>, count: Int): Task {
        val duration = TimeUnit.toJavaDuration(timeUnitProperty.value, count)
        if (timeUnitProperty is Constraint) {
            setDurationProperty(Constraint(timeUnitProperty.isVisible, duration, UNMET))
        } else setDurationProperty(Property(timeUnitProperty.isVisible, duration))

        return this
    }

    /**
     * Sets this Task's duration Constraint with the duration of the TimeUnit multiplied by the `count` as the
     * Constraint's value and the `timeUnitConstraint`'s Constraint values for this Task's duration Constraint values.
     *
     * This allows to use Custom Time Units for setting the duration.
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnitConstraint the Constraint of type `TimeUnit` that will be used to set this Task's duration
     * Constraint's visibility to and set the value to by multiplying by the `count` and this Task's duration's
     * `isMet` value to
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintTimeUnits(timeUnitConstraint: Constraint<TimeUnit>, count: Int): Task {
        val duration = TimeUnit.toJavaDuration(timeUnitConstraint.value, count)
        setDurationProperty(Constraint(timeUnitConstraint.isVisible, duration, timeUnitConstraint.isMet))
        return this
    }

    /**
     * Sets this Task's duration Property with the duration of the TimeUnit multiplied by the `count` as the Property's
     * value and makes the Property showing.
     *
     * This allows to use Custom Time Units for setting the duration and is shorthand for writing
     * `setDurationPropertyTimeUnits(Property(SHOWING, myTimeUnit), myCount)`
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnit the TimeUnit that will be used to set this Task's duration to by multiplying it by the
     * `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyTimeUnitsValue(timeUnit: TimeUnit, count: Int): Task {
        return setDurationProperty(Property(SHOWING, TimeUnit.toJavaDuration(timeUnit, count)))
    }

    /**
     * Sets this Task's duration Constraint with the duration of the TimeUnit multiplied by the `count` as the
     * Constraints's value and makes the Constraint showing and unmet.
     *
     * This allows to use Custom Time Units for setting the duration and is shorthand for writing
     * `setDurationConstraintTimeUnits(Constraint(SHOWING, myTimeUnit, UNMET), myCount)`
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnit the TimeUnit that will be used to set this Task's duration to by multiplying it by the
     * `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintTimeUnitsValue(timeUnit: TimeUnit, count: Int): Task {
        return setDurationProperty(Constraint(SHOWING, TimeUnit.toJavaDuration(timeUnit, count), UNMET))
    }

    /**
     * Sets this Task's priority Property.
     *
     * Priority is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for priority.
     *
     * @see Priority
     * @param priorityProperty the `Property` of type `Priority` that this Task's priority will be set to
     * @return this Task after setting the Task's priority Property
     */
    fun setPriorityProperty(priorityProperty: Property<Priority>): Task {
        this.priority = Property(priorityProperty.isVisible, priorityProperty.value)
        return this
    }

    /**
     * Sets this Task's priority Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setPriorityProperty(Property(SHOWING, myPriority))`.
     *
     * @see Task.setPriorityProperty
     * @param priority the Priority value that this Task's priority value will be set to
     * @return this Task after setting the Task's priority Property
     */
    fun setPriorityValue(priority: Priority): Task {
        return setPriorityProperty(Property(SHOWING, priority))
    }

    /**
     * Sets this Task's labels Property.
     *
     * Label is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for labels.
     *
     * @see Label
     * @param labelProperty the `Property` containing the list of all labels that this Task's labels property will be
     * set to
     * @return this Task after setting the Task's labels Property
     */
    fun setLabelsProperty(labelProperty: Property<ArrayList<Label>>): Task {
        this.labels = Property(labelProperty.isVisible, labelProperty.value)
        return this
    }

    /**
     * Sets this Task's labels Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setLabelsProperty(Property(SHOWING, myLabelList))`.
     *
     * @see Task.setLabelsProperty
     * @param labels the list of labels that this Task's labels Property will be set to
     * @return this Task after setting the Task's labels Property
     */
    fun setLabelsValue(vararg labels: Label): Task {
        return setLabelsProperty(Property(SHOWING, arrayListOf(*labels)))
    }

    /**
     * Adds the passed in labels to this Task's labels Property and makes this Task's labels Property showing if it
     * wasn't already.
     *
     * @see Label
     * @param labels the labels to add to this Task's labels Property
     * @return this Task after adding the labels to the Task's labels Property
     */
    fun addLabels(vararg labels: Label): Task {
        if (!this.labels.isVisible) {
            this.labels.isVisible = SHOWING
        }
        this.labels.value.addAll(labels)
        return this
    }

    /**
     * Removes a label from this Task's labels Property.
     *
     * @see Label
     * @param label the label to remove from this Task's labels Property
     * @return this Task after removing the label from the Task's labels Property
     */
    fun removeLabel(label: Label): Task {
        this.labels.value.remove(label)
        return this
    }

    /**
     * Sets this Task's optional Property.
     *
     * Optional is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for optional.
     *
     * @param optionalProperty the `Property` of type `Optional` that this Task's optional will be set to
     * @return this Task after setting the Task's optional Property
     */
    fun setOptionalProperty(optionalProperty: Property<Optional>): Task {
        this.optional = Property(optionalProperty.isVisible, optionalProperty.value)
        return this
    }

    /**
     * Sets this Task's optional Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setOptionalProperty(Property(SHOWING, myOptional))`.
     *
     * @see Task.setOptionalProperty
     * @param optional the Optional value that this Task's optional value will be set to
     * @return this Task after setting the Task's optional Property
     */
    fun setOptionalValue(optional: Optional): Task {
        return setOptionalProperty(Property(SHOWING, optional))
    }

    /**
     * Sets this Task's description Property.
     *
     * Description is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for description.
     *
     * @see StringBuilder
     * @param descriptionProperty the `Property` containing the description that this Task's description property
     * will be set to
     * @return this Task after setting the Task's description Property
     */
    fun setDescriptionProperty(descriptionProperty: Property<Description>): Task {
        this.description = Property(descriptionProperty.isVisible, descriptionProperty.value)
        return this
    }

    /**
     * Sets this Task's description Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDescriptionProperty(Property(SHOWING, myDescription))`.
     *
     * @see Task.setDescriptionProperty
     * @param description the description that this Task's description Property will be set to
     * @return this Task after setting the Task's description Property
     */
    fun setDescriptionValue(description: Description): Task {
        return setDescriptionProperty(Property(SHOWING, description))
    }

    /**
     * Sets this Task's checklist Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `checklistProperty` is a Constraint, otherwise no more changes
     * will occur.
     *
     * In the case that the passed in `checklistProperty` is a Constraint, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will start viewing the checklist to see if all its list items are checked, if they are, the checklist
     * Constraint is met, see [checklistConstraintChecking]
     *
     * Note: An empty checklist means every item in the checklist is checked so this can make the checklist
     * Constraint met
     *
     * If the passed in `checklistProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.checklistConstraintChecking
     * @see Checklist
     * @param checklistProperty the `Property` of type `Checklist` that this Task's checklist will be set to
     * @return this Task after setting the Task's checklist Property
     */
    fun setChecklistProperty(checklistProperty: Property<Checklist>): Task {
        this.checklist = checklistProperty
        if (checklistProperty is Constraint) {
            makeFailableIfConstraint(checklistProperty)
            checklistConstraintChecking()
        }
        return this
    }

    /**
     * Sets this Task's checklist Constraint.
     *
     * @see Task.setChecklistProperty
     * @param checklistConstraint the `Constraint` of type `Checklist` that this Task's checklist will be set to
     * @return this Task after setting the Task's checklist Constraint
     */
    fun setChecklistConstraint(checklistConstraint: Constraint<Checklist>): Task {
        return setChecklistProperty(checklistConstraint)
    }

    /**
     * Sets this Task's checklist Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setChecklistProperty(Property(SHOWING, myChecklist))`.
     *
     * @see Task.setChecklistProperty
     * @param checklist the Checklist value that this Task's checklist value will be set to
     * @return this Task after setting the Task's checklist Property
     */
    fun setChecklistPropertyValue(checklist: Checklist): Task {
        return setChecklistProperty(Property(SHOWING, checklist))
    }

    /**
     * Sets this Task's checklist Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setChecklistConstraint(Constraint(SHOWING, myChecklist, UNMET))`.
     *
     * @see Task.setChecklistProperty
     * @param checklist the Checklist value that this Task's checklist value will be set to
     * @return this Task after setting the Task's checklist Constraint
     */
    fun setChecklistConstraintValue(checklist: Checklist): Task {
        return setChecklistProperty(Constraint(SHOWING, checklist, UNMET))
    }

    /**
     * Sets this Task's deadline Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `deadlineProperty` is a Constraint.
     *
     * In the case that the passed in `deadlineProperty` is a Constraint, three things will happen:
     *
     * * The deadline Constraint will become met until that deadline time where it will become unmet again, this is
     * only in the case that the Task is not killed before the deadline, this is done in order to allow the Task to
     * be killed
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the time to compare it with the deadline, if the current time is after the
     * deadline plus the defined grace period [GRACE_PERIOD] then the Task becomes failed and the deadline Constraint
     * becomes unmet. See [deadlineConstraintChecking].
     *
     * If the passed in `deadlineProperty` is not a Constraint then there will be no further changes and the Task
     * will not fail automatically.
     *
     * @see Task.deadlineConstraintChecking
     * @param deadlineProperty the `Property` of type `java.time.LocalDateTime` that this Task's deadline will be set to
     * @return this Task after setting the Task's deadline Property
     */
    fun setDeadlineProperty(deadlineProperty: Property<Time>): Task {
        this.deadline = deadlineProperty
        if (deadlineProperty is Constraint) {
            makeFailableIfConstraint(deadlineProperty)
            deadlineConstraintChecking()
        }
        return this
    }

    /**
     * Gets the duration left until this Task's deadline will occur, this ignores the grace period.
     *
     * @return the Duration left until this Task's deadline occurs, ignores the grace period
     * @throws IllegalStateException if the deadline has not been set
     */
    fun getTimeUntilDeadline(): Duration {
        if (deadline.value == DEFAULT_DEADLINE) {
            throw IllegalStateException("Deadline not set!")
        } else {
            return Duration.between(now(), this.deadline.value)
        }
    }

    /**
     * Sets this Task's deadline Constraint.
     *
     * @see Task.setDeadlineProperty
     * @param deadlineConstraint the `Constraint` of type `java.time.LocalDateTime` that this Task's deadline will be
     * set to
     * @return this Task after setting the Task's deadline Constraint
     */
    fun setDeadlineConstraint(deadlineConstraint: Constraint<Time>): Task {
        return setDeadlineProperty(deadlineConstraint)
    }

    /**
     * Sets this Task's deadline Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDeadlineProperty(Property(SHOWING, myDeadline))`.
     *
     * @see Task.setDeadlineProperty
     * @param deadline the java.time.LocalDateTime value that this Task's deadline value will be set to
     * @return this Task after setting the Task's deadline Property
     */
    fun setDeadlinePropertyValue(deadline: Time): Task {
        return setDeadlineProperty(Property(SHOWING, deadline))
    }

    /**
     * Sets this Task's deadline Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setDeadlineConstraint(Constraint(SHOWING, myDeadline, UNMET))`.
     *
     * @see Task.setDeadlineProperty
     * @param deadline the java.time.LocalDateTime value that this Task's deadline value will be set to
     * @return this Task after setting the Task's deadline Constraint
     */
    fun setDeadlineConstraintValue(deadline: Time): Task {
        return setDeadlineProperty(Constraint(SHOWING, deadline, UNMET))
    }

    /**
     * Sets this Task's target Property, the passed in Property can be a Constraint.
     *
     * If the passed in `targetProperty` is a Constraint then this Task will become failable if it wasn't already.
     *
     * @see Target
     * @param targetProperty the `Property` of type `Target` that this Task's target will be set to
     * @return this Task after setting the Task's target Property
     */
    fun setTargetProperty(targetProperty: Property<Target>): Task {
        this.target = targetProperty
        makeFailableIfConstraint(targetProperty)
        return this
    }

    /**
     * Sets this Task's target Constraint.
     *
     * @see Task.setTargetProperty
     * @param targetConstraint the `Constraint` of type `Target` that this Task's target will be set to
     * @return this Task after setting the Task's target Constraint
     */
    fun setTargetConstraint(targetConstraint: Constraint<Target>): Task {
        return setTargetProperty(targetConstraint)
    }

    /**
     * Sets this Task's target Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setTargetProperty(Property(SHOWING, myTarget))`.
     *
     * @see Task.setTargetProperty
     * @param target the Target value that this Task's target value will be set to
     * @return this Task after setting the Task's target Property
     */
    fun setTargetPropertyValue(target: Target): Task {
        return setTargetProperty(Property(SHOWING, target))
    }

    /**
     * Sets this Task's target Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setTargetConstraint(Constraint(SHOWING, myTarget, UNMET))`.
     *
     * @see Task.setTargetProperty
     * @param target the Target value that this Task's checklist value will be set to
     * @return this Task after setting the Task's checklist Constraint
     */
    fun setTargetConstraintValue(target: Target): Task {
        return setTargetProperty(Constraint(SHOWING, target, UNMET))
    }

    /**
     * Sets this Task's before Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `beforeProperty` is a Constraint, otherwise no more changes
     * will occur.
     *
     * In the case that the passed in `beforeProperty` is a Constraint, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the state of task the before value refers to using the database, and will make
     * the before Constraint met only when the before Task is killed, see [beforeConstraintChecking]
     *
     * If the passed in `beforeProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.beforeConstraintChecking
     * @param beforeProperty the `Property` of type `TaskID` that this Task's before property will be set to, this is
     * the before Task's TaskID
     * @return this Task after setting the Task's before Property
     */
    fun setBeforeProperty(beforeProperty: Property<TaskID>): Task {
        this.before = beforeProperty
        if (beforeProperty is Constraint) {
            makeFailableIfConstraint(beforeProperty)
            beforeConstraintChecking()
        }
        return this
    }

    /**
     * Sets this Task's before Constraint.
     *
     * @see Task.setBeforeProperty
     * @param beforeConstraint the `Constraint` of type `TaskID` that this Task's before will be set to
     * @return this Task after setting the Task's before Constraint
     */
    fun setBeforeConstraint(beforeConstraint: Constraint<TaskID>): Task {
        return setBeforeProperty(beforeConstraint)
    }

    /**
     * Sets this Task's before Property with the given TaskID value and makes the Property showing.
     *
     * This is a shorthand of writing `setBeforeProperty(Property(SHOWING, myBefore))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeTaskID the TaskID of the Task that is before this one that this Task's before value will be set to
     * @return this Task after setting the Task's before Property
     */
    fun setBeforePropertyValue(beforeTaskID: TaskID): Task {
        return setBeforeProperty(Property(SHOWING, beforeTaskID))
    }

    /**
     * Sets this Task's before Constraint with the given TaskID value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setBeforeConstraint(Constraint(SHOWING, myBefore, UNMET))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeTaskID the TaskID of the Task that is before this one that this Task's before value will be set to
     * @return this Task after setting the Task's before Constraint
     */
    fun setBeforeConstraintValue(beforeTaskID: TaskID): Task {
        return setBeforeProperty(Constraint(SHOWING, beforeTaskID, UNMET))
    }

    /**
     * Sets this Task's before Property with the given Task value and makes the Property showing.
     *
     * This is a shorthand of writing `setBeforeProperty(Property(SHOWING, myBefore))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeTask the Task that is before this one that this Task's before value will be set to
     * @return this Task after setting the Task's before Property
     */
    fun setBeforePropertyValue(beforeTask: Task): Task {
        return setBeforeProperty(Property(SHOWING, beforeTask.taskID))
    }

    /**
     * Sets this Task's before Constraint with the given Task value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setBeforeConstraint(Constraint(SHOWING, myBefore, UNMET))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeTask the Task that is before this one that this Task's before value will be set to
     * @return this Task after setting the Task's before Constraint
     */
    fun setBeforeConstraintValue(beforeTask: Task): Task {
        return setBeforeProperty(Constraint(SHOWING, beforeTask.taskID, UNMET))
    }

    /**
     * Sets this Task's sub-Tasks Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `subTasksProperty` is a Constraint, otherwise no more changes
     * will occur.
     *
     * In the case that the passed in `subTasksProperty` is a Constraint, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the state of all of its sub-Tasks, if all are KILLED then the sub-Tasks
     * Constraint is met, if any one sub-Task is FAILED then this Task is FAILED if it is failable, see [subTasksConstraintChecking]
     *
     * If the passed in `subTasksProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.subTasksConstraintChecking
     * @param subTasksProperty the `Property` of type `ArrayList<TaskID>` that this Task's subTasks property will be
     * set to, this is the list of TaskIDs of the sub-Tasks
     * @return this Task after setting the Task's subTasks Property
     */
    fun setSubTasksProperty(subTasksProperty: Property<ArrayList<TaskID>>): Task {
        this.subTasks = subTasksProperty
        if (subTasksProperty is Constraint) {
            makeFailableIfConstraint(subTasksProperty)
            subTasksConstraintChecking()
        }
        return this
    }

    /**
     * Sets this Task's subTasks Constraint.
     *
     * @see Task.setSubTasksProperty
     * @param subTasksConstraint the `Constraint` of type `ArrayList<TaskID>` that this Task's subTasks will be set to
     * @return this Task after setting the Task's subTasks Constraint
     */
    fun setSubTasksConstraint(subTasksConstraint: Constraint<ArrayList<TaskID>>): Task {
        return setSubTasksProperty(subTasksConstraint)
    }

    /**
     * Sets this Task's subTasks Property with the given ArrayList of TaskIDs and makes the Property showing.
     *
     * This is a shorthand of writing `setSubTasksProperty(Property(SHOWING, mySubTasks))`.
     *
     * @see Task.setSubTasksProperty
     * @param subTasks the ArrayList of TaskIDs of the subTasks that this Task's subTasks value will be set to
     * @return this Task after setting the Task's subTasks Property
     */
    fun setSubTasksPropertyValue(subTasks: ArrayList<TaskID>): Task {
        return setSubTasksProperty(Property(SHOWING, subTasks))
    }

    /**
     * Sets this Task's subTasks Constraint with the given ArrayList of TaskIDs and makes the Constraint showing and
     * unmet.
     *
     * This is a shorthand of writing `setSubTasksConstraint(Constraint(SHOWING, mySubTasks, UNMET))`.
     *
     * @see Task.setSubTasksProperty
     * @param subTasks he ArrayList of TaskIDs of the subTasks that this Task's subTasks value will be set to
     * @return this Task after setting the Task's subTasks Constraint
     */
    fun setSubTasksConstraintValue(subTasks: ArrayList<TaskID>): Task {
        return setSubTasksProperty(Constraint(SHOWING, subTasks, UNMET))
    }

    /**
     * Adds the given subTasks to this Task's subTasks Property and makes this Task's subTasks Property showing if it
     * wasn't already.
     *
     * @param tasks the Tasks to add to this Task's subTasks Property
     * @return this Task after adding the given subTasks to the Task's subTasks Property
     */
    fun addSubTasks(vararg tasks: Task): Task {
        val value = this.subTasks.value
        value.addAll(tasksToTaskIDs(tasks.toList()))
        setSubTasksProperty(Property(SHOWING, value))

        return this
    }

    /**
     * Gets the ArrayList of TaskIDs of the sub-Tasks of this Task
     *
     * @return the ArrayList of TaskIDs of the sub-Tasks of this Task
     */
    fun getSubTasksIDsList(): ArrayList<TaskID> {
        return this.subTasks.value
    }

    /**
     * Gets the ArrayList of Tasks of the sub-Tasks of this Task
     *
     * @return the ArrayList of Tasks of the sub-Tasks of this Task
     */
    fun getSubTasksList(): ArrayList<Task> {
        return ArrayList(taskIDsToTasks(this.subTasks.value))
    }

    /**
     * Gets the maximum depth of sub-Tasks of this Task, this is a recursive function
     *
     * @return the maximum depth of sub-Tasks of this Task
     */
    fun getSubTasksLevelsDepth(task: Task = this): Int {
        val list = arrayListOf<Int>()
        return if (task.subTasks.value.isEmpty()) {
            0
        } else {
            for (task0 in taskIDsToTasks(task.subTasks.value)) {
                list.add(getSubTasksLevelsDepth(task0) + 1)
            }
            list.max() as Int
        }
    }

    //endregion Property setters for chaining

    //region Hide Properties

    // TODO: 24-Mar-18 Document this stuff
    fun hideTime() {
        if (isNotConstraint(time)) {
            time = DEFAULT_TIME_PROPERTY
        } else throw IllegalStateException("Cannot hide, time is Constraint")
    }

    fun hideDuration() {
        if (isNotConstraint(duration)) {
            duration = DEFAULT_DURATION_PROPERTY
        } else throw IllegalStateException("Cannot hide, duration is Constraint")
    }

    fun hidePriority() {
        if (isNotConstraint(priority)) {
            priority = DEFAULT_PRIORITY_PROPERTY
        } else throw IllegalStateException("Cannot hide, priority is Constraint")
    }

    fun hideLabel() {
        if (isNotConstraint(labels)) {
            labels = DEFAULT_LABELS_PROPERTY
        } else throw IllegalStateException("Cannot hide, labels is Constraint")
    }

    fun hideOptional() {
        if (isNotConstraint(optional)) {
            optional = DEFAULT_OPTIONAL_PROPERTY
        } else throw IllegalStateException("Cannot hide, optional is Constraint")
    }

    fun hideDescription() {
        if (isNotConstraint(description)) {
            description = DEFAULT_DESCRIPTION_PROPERTY
        } else throw IllegalStateException("Cannot hide, description is Constraint")
    }

    fun hideChecklist() {
        if (isNotConstraint(checklist)) {
            checklist = DEFAULT_CHECKLIST_PROPERTY
        } else throw IllegalStateException("Cannot hide, checklist is Constraint")
    }

    fun hideDeadline() {
        if (isNotConstraint(deadline)) {
            deadline = DEFAULT_DEADLINE_PROPERTY
        } else throw IllegalStateException("Cannot hide, deadline is Constraint")
    }

    fun hideTarget() {
        if (isNotConstraint(target)) {
            target = DEFAULT_TARGET_PROPERTY
        } else throw IllegalStateException("Cannot hide, target is Constraint")
    }

    fun hideBefore() {
        if (isNotConstraint(before)) {
            before = DEFAULT_BEFORE_PROPERTY
        } else throw IllegalStateException("Cannot hide, before is Constraint")
    }

    fun hideSubTasks() {
        if (isNotConstraint(subTasks)) {
            subTasks = DEFAULT_SUB_TASKS_PROPERTY
        } else throw IllegalStateException("Cannot hide, subTasks is Constraint")
    }

    //endregion Hide Properties

    //region Task lifecycle

    fun getTaskState() = state

    fun canKill() = isKillable &&
            this.state == TaskState.EXISTING &&
            getAllUnmetAndShowingConstraints().isEmpty()


    fun canFail() = isFailable &&
            this.state == TaskState.EXISTING

    fun canSleep() = getTaskState() == TaskState.FAILED

    fun fail() {
        if (state == TaskState.FAILED) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is already Failed!", getTaskState())
        }
        if (!isFailable) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is not Failable", getTaskState())
        } else if (canFail()) {
            state = TaskState.FAILED
            age++
            failedTimes.add(now())
        } else {
            throw TaskStateException("Fail unsuccessful, unknown reason, remember only EXISTING tasks can be failed!", getTaskState())
        }
    }

    fun sleep() {
        if (state == TaskState.SLEEPING) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is already Sleeping!", getTaskState())
        }
        if (state == TaskState.KILLED) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is Killed!", getTaskState())
        }
        if (state == TaskState.EXISTING) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is Existing!", getTaskState())
        } else if (canSleep()) {
            state = TaskState.SLEEPING
        } else {
            throw TaskStateException("Sleep unsuccessful, unknown reason, remember only FAILED tasks can be slept!", getTaskState())
        }
    }

    // If a Task is killed it can be modified because it doesn't matter at all, after killed there is no other State.
    //TODO This isn't entirely true! We need to do something to make sure that Killed Tasks can't be meddled with much
    fun kill() {
        if (state == TaskState.KILLED) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is already Killed!", getTaskState())
        }
        if (!isKillable) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is not Killable", getTaskState())
        }
        if (state == TaskState.FAILED) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is FAILED", getTaskState())
        }
        if (getAllUnmetAndShowingConstraints().isNotEmpty()) {
            throw TaskStateException(
                    "Kill unsuccessful, ${this.title} has unmet Constraints ${this.getAllUnmetAndShowingConstraints()}",
                    getTaskState())
        } else if (canKill()) {
            state = TaskState.KILLED
            killedTime = now()
        } else {
            throw TaskStateException("Kill unsuccessful, unknown reason, remember only EXISTING tasks can be killed!", getTaskState())
        }
    }

    //endregion Task lifecycle

    //region Concurrency

    /**
     * Checks the time on the `stateCheckingThread` to match it with this Task's time Constraint value.
     *
     * When the time is past this Task's time Constraint value the state will change to EXISTING and the time
     * Constraint will be met if it wasn't already and the checking ends.
     *
     * If this Task's time is no longer a Constraint (time is un-constrained) then the changes
     * [setTimeProperty] will be undone, namely:
     *
     * * This Task's state will become EXISTING
     * * This Task will become non-failable if there are no Constraints
     * * The time checking will end
     *
     * If the time Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking the
     * new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `time` is set as a Constraint and the time value is in the future.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @see Task.setTimeProperty
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons
     */
    private fun timeConstraintTimeChecking() {
        val originalValue = this.time.value
        var done = false

        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .subscribeOn(TIME_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                                this.time !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    this.state = TaskState.EXISTING
                                    done = true
                                }
                                this.time.value != originalValue -> {
                                    done = true
                                }
                                now().isAfter(this.time.value) -> {
                                    this.state = TaskState.EXISTING
                                    if (this.time is Constraint && (this.time as Constraint).isMet != MET) {
                                        (this.time as Constraint).isMet = MET
                                    }
                                    done = true
                                }
                            }
                        },
                        {
                            throw ConcurrentException("Time Constraint time checking failed!")
                        }
                )
    }

    /**
     * Checks the time that this Task's duration will end on the `stateCheckingThread` to match it with this Task's
     * duration Constraint value
     *
     * When the time is past this Task's duration Constraint value the duration Constraint will be met if it wasn't
     * already and the checking ends.
     *
     * If this Task's duration is no longer a Constraint (duration is un-constrained) then the changes
     * [setDurationProperty] will be undone, namely:
     *
     * * This Task will become non-failable if there are no Constraints
     * * The duration checking will end
     *
     * If the duration Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking
     * the new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `duration` is set as a Constraint.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @see Task.setTimeProperty
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons
     */
    private fun durationConstraintTimeChecking() {
        val originalValue = this.duration.value
        var done = false
        val minimumTime = now().plus(this.duration.value)

        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .subscribeOn(DURATION_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                                this.duration !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    done = true
                                }
                                this.duration.value != originalValue -> {
                                    done = true
                                }
                                now().isAfter(minimumTime) -> {
                                    if (this.duration is Constraint && (this.duration as Constraint).isMet != MET) {
                                        (this.duration as Constraint).isMet = MET
                                    }
                                    done = true
                                }
                            }
                        },
                        {
                            throw ConcurrentException("Duration Constraint time checking failed!")
                        }
                )
    }

    /**
     * Checks this Task's checklist Property value (the actual checklist) on the `stateCheckingThread` to see if all
     * its list items are checked or not.
     *
     * When the checklist has no unchecked items this Task's checklist Constraint will be met if it wasn't already
     * and the checking ends.
     *
     * If this Task's checklist is no longer a Constraint (checklist is un-constrained) then the changes
     * [setChecklistProperty] will be undone, namely:
     *
     * * This Task will become non-failable if there are no Constraints
     * * The checklist checking will end
     *
     * If the checklist Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking
     * the new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `checklist` is set as a Constraint.
     *
     * @see Task.setChecklistProperty
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons
     */
    private fun checklistConstraintChecking() {
        val originalValue = this.checklist.value
        var done = false

        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .subscribeOn(CHECKLIST_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                                this.checklist !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    done = true
                                }
                                this.checklist.value != originalValue -> {
                                    done = true
                                }
                                this.checklist.value.getAllUncheckedItems().isEmpty() -> {
                                    if (this.checklist is Constraint && (this.checklist as Constraint).isMet != MET) {
                                        (this.checklist as Constraint).isMet = MET
                                    }
                                    done = true
                                }
                            }
                        },
                        {
                            throw ConcurrentException("Checklist Constraint checking failed")
                        }
                )
    }

    /**
     * Checks the time on the `stateCheckingThread` to match it with this Task's deadline Constraint value plus the
     * grace period [GRACE_PERIOD].
     *
     * When the time is past this Task's deadline Constraint value plus the grace period, the state will change to
     * FAILED and the deadline Constraint will be unmet and the checking ends.
     *
     * If this Task's deadline is no longer a Constraint (deadline is un-constrained) then the changes
     * [setDeadlineProperty] will be undone, namely:
     *
     * * This Task will become non-failable if there are no Constraints
     * * The deadline checking will end
     *
     * If the checklist Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking
     * the new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `deadline` is set as a Constraint.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @see Task.setDeadlineProperty
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons
     */
    private fun deadlineConstraintChecking() {
        var done = false
        val originalValue = this.deadline.value
        val deadlineWithGrace = this.deadline.value.plus(GRACE_PERIOD)

        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .doOnSubscribe { (deadline as Constraint).isMet = true }
                .subscribeOn(DEADLINE_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                                this.deadline !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    done = true
                                }
                                this.deadline.value != originalValue -> {
                                    done = true
                                }
                                now().isAfter(deadlineWithGrace) -> {
                                    if (canFail()) {
                                        this.fail()
                                        (deadline as Constraint).isMet = false
                                    }
                                    done = true
                                }
                            }
                        },
                        {
                            throw ConcurrentException("Deadline Constraint checking failed!")
                        }
                )

    }

    /**
     * Checks the state of the Task before this one on the `otherTaskCheckingThread`. If it is failed then this Task
     * will fail if it can, if it is killed then the before Constraint is met.
     *
     * If the before Task's state is FAILED then this Task will fail if it can [canFail].
     *
     * If the before Task's state is KILLED then this Task's before Constraint will be met.
     *
     * If this Task's before is no longer a Constraint (before is un-constrained) then the changes
     * [setBeforeProperty] will be undone, namely:
     *
     * * This Task will become non-failable if there are no Constraints
     * * The before checking will end
     *
     * If the before Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking
     * the new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `before` is set as a Constraint.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @see Task.setBeforeProperty
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons or if the before Task cannot
     * be found in the database
     */
    private fun beforeConstraintChecking() {
        var done = false
        val originalValue = this.before.value
        val beforeTask = DATABASE[this.before.value]

        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .subscribeOn(BEFORE_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                                this.before !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    done = true
                                }
                                this.before.value != originalValue -> {
                                    done = true
                                }
                                beforeTask == null -> {
                                    throw ConcurrentException("Before Constraint checking failed!" +
                                            " Before is null in database")
                                }
                                beforeTask.getTaskState() == TaskState.KILLED -> {
                                    (this.before as Constraint).isMet = true
                                    done = true
                                }
                                beforeTask.getTaskState() == TaskState.FAILED -> {
                                    (this.before as Constraint).isMet = false
                                    if (canFail()) fail()
                                    done = true
                                }

                            }
                        },
                        {
                            throw ConcurrentException("Before Constraint checking failed!")
                        }
                )
    }

    /**
     * Checks the state of the sub-Tasks of this Task on the `otherTaskCheckingThread`.
     *
     * If any of the sub-Tasks' states is FAILED then this Task will fail if it can [canFail].
     *
     * If all of the sub-Tasks' states is KILLED then this Task's subTasks Constraint will be met.
     *
     * If this Task's subTasks is no longer a Constraint (subTasks is un-constrained) then the changes
     * [setSubTasksProperty] will be undone, namely:
     *
     * * This Task will become non-failable if there are no Constraints
     * * The subTasks checking will end
     *
     * If the subTasks Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking
     * the new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `subTasks` is set as a Constraint.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @see Task.setSubTasksProperty
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons
     */
    private fun subTasksConstraintChecking() {
        val originalValue = this.subTasks.value
        var done = false

        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .subscribeOn(SUB_TASKS_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                                this.subTasks !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    done = true
                                }
                                this.subTasks.value != originalValue -> {
                                    done = true
                                }
                            // SubTasks contains more than 0 failed Tasks
                                taskIDsToTasks(this.subTasks.value).any { it.getTaskState() == TaskState.FAILED } -> {
                                    (subTasks as Constraint).isMet = false
                                    if (canFail()) fail()
                                    done = true
                                }
                            // All SubTasks are killed
                                taskIDsToTasks(this.subTasks.value)
                                        .all { it.getTaskState() == TaskState.KILLED } -> {
                                    (subTasks as Constraint).isMet = true
                                    done = true
                                }

                            }
                        },
                        {
                            throw ConcurrentException("SubTasks Constraint checking failed!")
                        }
                )
    }

    //endregion Concurrency

    //region Overriden from kotlin.Any

    /**
     * Returns the hash code of this Task, this is the hash code of this Task's equalityBundle, see [equalityBundle]
     *
     * @see java.util.AbstractMap.hashCode
     * @see Any.hashCode
     * @return the hash code of this Task
     */
    override fun hashCode() = equalityBundle().hashCode()

    /**
     * Checks whether the given `other` is equal to this Task or not, if `other` is not a Task then returns false, then
     * determines that the Tasks are equal if and only if their bundles are equal [equalityBundle]
     *
     * @see Task.equalityBundle
     * @see Any.equals
     * @return true if `other` is a Task and its equalityBundle is equal to this Task's equalityBundle, false otherwise
     */
    override fun equals(other: Any?) =
            other is Task && other.equalityBundle() == this.equalityBundle()

    /**
     * Returns the String representation of this Task, depicted using Task Card syntax which appears as follows:
     * ```
     * "My Task"
     * ID: 123456789 isKillable: true isFailable: false state: EXISTING
     *     P:
     *         ...
     *     C:
     *         ...
     * ```
     *
     * The Properties and Constraints are represented using their toString function. [Property.toString] [Constraint.toString]
     *
     * @see Any.toString
     * @return the String representation of this Task
     */
    override fun toString(): String {
        val result = StringBuilder("$title\n")
        result.append("ID: $taskID isKillable: $isKillable isFailable: $isFailable state: $state\n")

        result.append("\tP:\n")
        getAllShowingProperties().filter { it !is Constraint }.forEach { result.append("\t\t$it\n") }

        result.append("\tC:\n")
        getAllShowingConstraints().forEach { result.append("\t\t$it\n") }

        return result.toString()
    }

    //endregion Overriden from kotlin.Any

    //region Template Task

    /**
     * Returns the information of this Task's Properties in the form of a [Bundle]
     *
     * @see Task.Template.toTemplate
     * @return the Bundle representing this Task's Properties information
     */
    fun toTemplate() = Task.Template.toTemplate(this)

    /**
     * Sets this Task's Properties from the information of the passed in Task's Properties, essentially the passed in
     * Task has its [Bundle] retrieved and used to set this Task's Properties if and only if the Property is not
     * equal to its default value, see [Task.Template.fromTemplate] for more information
     *
     * @see Task.Template.fromTemplate
     * @param task the Task from which this Task's Properties information will be set
     * @return this Task after setting its Properties based on the passed in Task
     */
    fun fromTemplate(task: Task) = Task.Template.fromTemplate(task.toTemplate())

    // TODO: 24-Mar-18 Document this later
    object Template {
        private const val initialName = "New Task"
        private const val time = "time"
        private const val duration = "duration"
        private const val priority = "priority"
        private const val labels = "labels"
        private const val optional = "optional"
        private const val description = "description"
        private const val checklist = "checklist"
        private const val deadline = "deadline"
        private const val target = "target"
        private const val before = "before"
        private const val subTasks = "subTasks"

        /**
         * Returns a Task with the Properties of the passed in Bundle, this is not recommended to be used outside of
         * the Task class, instead use [Task.fromTemplate]
         *
         * A [Bundle] is essentially a [HashMap] with [String] as the Key and [Property] as the Value, what this
         * function does is it unpacks the passed in Bundle and returns a Task with the Properties contained in the
         * Bundle if and only if the Properties in the Bundle are not their default values.
         *
         * @see Task.fromTemplate
         * @see Bundle
         * @param bundle the Bundle containing the Properties information from another Task see [Task.Template.toTemplate]
         * @return the Task with the Properties set from the passed in Bundle
         */
        @Suppress("UNCHECKED_CAST")
        fun fromTemplate(bundle: Bundle<String, Property<*>>): Task {
            val task = Task(initialName)
            if (bundle[time] != DEFAULT_TIME_PROPERTY) {
                task.setTimeProperty(bundle[time] as Property<Time>)
            }
            if (bundle[duration] != DEFAULT_DURATION_PROPERTY) {
                task.setDurationProperty(bundle[duration] as Property<Duration>)
            }
            if (bundle[priority] != DEFAULT_PRIORITY_PROPERTY) {
                task.setPriorityProperty(bundle[priority] as Property<Priority>)
            }
            if (bundle[labels] != DEFAULT_LABELS_PROPERTY) {
                task.setLabelsProperty(bundle[labels] as Property<ArrayList<Label>>)
            }
            if (bundle[optional] != DEFAULT_OPTIONAL_PROPERTY) {
                task.setOptionalProperty(bundle[optional] as Property<Optional>)
            }
            if (bundle[description] != DEFAULT_DESCRIPTION_PROPERTY) {
                task.setDescriptionProperty(bundle[description] as Property<Description>)
            }
            if (bundle[checklist] != DEFAULT_CHECKLIST_PROPERTY) {
                task.setChecklistProperty(bundle[checklist] as Property<Checklist>)
            }
            if (bundle[deadline] != DEFAULT_DEADLINE_PROPERTY) {
                task.setDeadlineProperty(bundle[deadline] as Property<LocalDateTime>)
            }
            if (bundle[target] != DEFAULT_TARGET_PROPERTY) {
                task.setTargetProperty(bundle[target] as Property<Target>)
            }
            if (bundle[before] != DEFAULT_BEFORE_PROPERTY) {
                task.setBeforeProperty(bundle[before] as Property<TaskID>)
            }
            if (bundle[subTasks] != DEFAULT_SUB_TASKS_PROPERTY) {
                task.setSubTasksProperty(bundle[subTasks] as Property<ArrayList<TaskID>>)
            }
            return task
        }

        /**
         * Returns the Bundle of the passed in Task representing its Properties, this is used to send the information
         * of the passed in Task to a new Task from a template see [Task.Template.fromTemplate], this is not recommended to be
         * used outside of the Task class, instead use [Task.toTemplate]
         *
         * A [Bundle] is essentially a [HashMap] with [String] as the Key and [Property] as the Value, what this
         * function does is it packs the passed in Task's Properties information into a Bundle and returns the Bundle
         * containing the Properties information.
         *
         * @see Task.toTemplate
         * @see Bundle
         * @param task the Task to extract its Properties information from
         * @return the Bundle representing the passed in Task's Properties information
         */
        fun toTemplate(task: Task): Bundle<String, Property<*>> {
            val bundle = Bundle<String, Property<*>>(11)
            bundle[time] = task.time
            bundle[duration] = task.duration
            bundle[priority] = task.priority
            bundle[labels] = task.labels
            bundle[optional] = task.optional
            bundle[description] = task.description
            bundle[checklist] = task.checklist
            bundle[deadline] = task.deadline
            bundle[target] = task.target
            bundle[before] = task.before
            bundle[subTasks] = task.subTasks
            return bundle
        }
    }

    //endregion Template Task
}
