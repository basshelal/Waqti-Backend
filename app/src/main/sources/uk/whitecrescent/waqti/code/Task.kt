package uk.whitecrescent.waqti.code

import io.reactivex.Observable
import java.time.Duration
import java.time.LocalDateTime
import java.util.Random

//TODO make sure KDoc is up to date
class Task(var title: String) {

    //region Class Properties

    /**
     * The Task State is the state in which the task is in at this point in time.
     * By default this is set to EXISTING.
     * See The Task Lifecycle Documentation for more information
     * @see TaskState
     */
    private var state = DEFAULT_TASK_STATE

    /**
     * Boolean value representing whether it is possible for this Task to be failed at any arbitrary point in time.
     * Note that this is not the same as whether it can be failed right now, however if a Task's `isFailable`
     * is `false` then it can not be failed at this point in time.
     * @see TaskState
     * @see Constraint
     */
    var isFailable = DEFAULT_FAILABLE

    /**
     * Boolean value representing whether it is possible for this Task to be killed at any arbitrary point in time.
     * Note that this is not the same as whether it can be killed right now, however if a Task's `isKillable`
     * is `false` then it can not be killed at this point in time.
     * @see TaskState
     */
    var isKillable = DEFAULT_KILLABLE

    /**
     * A Long value representing an ID for a Task.
     * Every Task has a unique identifier which is generated by means of pseudo-random number designation.
     * No 2 Tasks can have the same taskID, all taskIDs are positive Long values generated randomly.
     * The list of all currently used IDs should be stored persistently.
     * @see java.util.Random.nextLong
     */
    var taskID = Math.abs(Random().nextLong())

    /**
     * The point in time at which the duration Property was set, used to calculate duration left by adding the
     * duration set to the time it was set to get the time it is due and then getting the duration between now and
     * the time it is due. This means that duration left is calculated when requested and not ongoing as the duration
     * decreases.
     */
    private var timeDurationSet = DEFAULT_TIME

    // A Task ages when it is failed
    var age = 0

    // The times a task has been failed
    var failedTimes = arrayListOf<Time>()

    // The time a task is killed
    var killedTime = Time.MIN

    //endregion Class Properties

    //region Task Properties

    /**
     * The point in natural time after which this Task will be relevant, this can also be referred to as scheduled
     * time.
     *
     * If time is a Constraint then the Task cannot be killed until after that time
     * and is in the SLEEPING state during that period, however, if time is not a Constraint then the Task can be
     * killed freely and will be in its previous state meaning no lifecycle change will be made. If time is a
     * Property then it has no rules on killing the Task.
     *
     * @see LocalDateTime
     */
    var time: Property<Time> = DEFAULT_TIME_PROPERTY
        private set(time) {
            field = time
        }

    /**
     * The estimated amount of time that this Task will take, this can also be referred to as minimum duration.
     *
     * This is defined in any Time Measurement Unit, either as a standard Time Unit such as seconds or days etc or
     * custom Time Units [TimeUnit]. This can also be referred to as minimum duration. If duration is a Constraint
     * then the Task cannot be killed in the midst of the duration, it can be killed only after it has ended. If
     * duration is a Property then it has no rules on killing the Task.
     *
     * @see Duration
     * @see TimeUnit
     */
    var duration: Property<Duration> = DEFAULT_DURATION_PROPERTY
        private set(duration) {
            field = duration
        }

    /**
     * The user defined level of importance of a Task represented as a String with a number representing importance
     * level.
     *
     * Priority is particularly useful in solving or mediating Task collisions within collections. A Task collision
     * occurs when two or more Tasks in a collection share the same time, if they have different priority levels then
     * the Task with the higher priority level will be shown and a collision warning will be displayed to the user,
     * this is called a weak collision. If the tasks have equal priority levels then the user must mediate or solve
     * the collision themselves, this is called a strong collision.
     *
     * Priority can not be a Constraint.
     *
     * @see Priority
     */
    var priority: Property<Priority> = DEFAULT_PRIORITY_PROPERTY
        private set(priority) {
            field = priority
        }

    /**
     * The user defined category(s) that this Task belongs to.
     *
     * A Task can belong to or have 0 or many labels. Labels are used as a way of categorizing Tasks and are thus
     * helpful in filtering and analytics.
     *
     * Labels can not be a Constraint.
     *
     * @see Label
     */
    var labels: Property<ArrayList<Label>> = DEFAULT_LABEL_PROPERTY
        private set(label) {
            field = label
        }

    /**
     * Shows whether the Task is optional or not.
     *
     * An optional Task is one that is to be done or pursued if there is free time, thus an optional Task has less
     * priority than a non-optional Task (mandatory Task) even if the Task has the lowest priority, this makes
     * optional Tasks the lowest priority of all Tasks. In many ways the optional Property acts similar to the priority
     * Property except in that optional is lower priority than the lowest priority.
     *
     * Optional can not be a Constraint.
     *
     * @see Boolean
     */
    var optional: Property<Optional> = DEFAULT_OPTIONAL_PROPERTY
        private set(optional) {
            field = optional
        }

    /**
     * A textual description of this Task, useful for if the Task is complex or requires further information that the
     * title cannot provide.
     *
     * Description can not be a Constraint.
     *
     * @see StringBuilder
     */
    var description: Property<Description> = DEFAULT_DESCRIPTION_PROPERTY
        private set(description) {
            field = description
        }

    /**
     * A list of checkable items that this Task may have.
     *
     * This is useful if the Task can be broken down into smaller chunks which can be represented as list items in a
     * checklist. Items in a checklist can be checked or deleted.
     *
     * If a checklist is a Constraint then the Task cannot be killed unless every item in the checklist is checked,
     * more specifically the checklist has no unchecked items. An empty checklist has no unchecked items so it is
     * important that the implementation be aware of this and differentiate between an empty checklist (which is
     * possible for good reasons) and a checklist with all its items checked.
     *
     * If checklist is a Property then it has no rules on killing the Task.
     *
     * @see Checklist
     * @see ListItem
     */
    var checklist: Property<Checklist> = DEFAULT_CHECKLIST_PROPERTY
        private set(checklist) {
            field = checklist
        }

    /**
     * The point in natural time after which this Task can no longer be killed and thus is FAILED.
     *
     * If deadline is a Constraint then after the deadline time passes plus the grace period [GRACE_PERIOD] the Task will be
     * FAILED and thus no longer can be KILLED.
     *
     * If deadline is a Property it has no rules on failing or killing the Task.
     *
     * @see LocalDateTime
     * @see GRACE_PERIOD
     */
    var deadline: Property<Time> = DEFAULT_DEADLINE_PROPERTY
        private set(deadline) {
            field = deadline
        }

    var target: Property<Target> = DEFAULT_TARGET_PROPERTY
        private set(target) {
            field = target
        }

    // The Task before this
    var before: Property<TaskID> = DEFAULT_BEFORE_PROPERTY
        private set(before) {
            field = before
        }

    // The Task after this
    var after: Property<TaskID> = DEFAULT_AFTER_PROPERTY
        private set(after) {
            field = after
        }

    //TODO Implement this guy everywhere please but define him in the .md
    var subTasks: Property<ArrayList<TaskID>> = DEFAULT_SUB_TASKS_PROPERTY
        private set(subTasks) {
            field = subTasks
        }


    //endregion Task Properties

    //region Task Properties Functions

    /**
     * Makes this Task failable if the passed in Property is a Constraint and this Task is not currently failable.
     * @see Property
     * @see Constraint
     * @see isFailable
     * @param property the Property to check for if it is a Constraint
     */
    private fun makeFailableIfConstraint(property: Property<*>) {
        if (!this.isFailable && property is Constraint) {
            this.isFailable = true
        }
    }

    /**
     * Gets the list of all the Properties of a Task, does not matter what their values are.
     * See the Properties.md docs for more.
     * @return the list of all the Properties of a Task.
     */
    private fun getAllProperties() = listOf(
            time,
            duration,
            priority,
            labels,
            optional,
            description,
            checklist,
            deadline,
            target,
            before,
            after
    )

    /**
     * Gets the list of all Constraints of this Task, does not matter what their values are as long as they are
     * Constraints.
     * @return the list of all current Constraints of this Task
     */
    private fun getAllConstraints() =
            getAllProperties().filter { it is Constraint }

    /**
     * Gets the list of all Properties of this Task that are showing. These would usually be the Properties of
     * interest.
     * @see Property
     * @return the list of all showing Properties this Task has
     */
    fun getAllShowingProperties() =
            getAllProperties().filter { it.isVisible }

    /**
     * Gets the list of all Constraints of this Task that are showing. The `isMet` value of the Constraints is ignored.
     * @see Constraint
     * @return the list of all showing Constraints this Task has
     */
    fun getAllShowingConstraints() =
            getAllConstraints().filter { it.isVisible }

    /**
     * Gets the list of all Constraints of this Task that are showing and also unmet. These would usually be the
     * Constraints of interest and the Constraints that would prevent a Task from being killed.
     * A Task can only be killed if this list is empty.
     * @see Constraint
     * @see canKill
     * @see kill
     * @return the list of all showing and unmet Constraints this Task has
     */
    fun getAllUnmetAndShowingConstraints() =
            getAllConstraints().filter { !(it as Constraint).isMet && it.isVisible }

    /**
     * Checks whether the passed in Property is a Constraint or not.
     * @see Property
     * @see Constraint
     * @param property the property to check whether it is a Constraint or not
     * @return true if the Property is a Constraints and false otherwise
     */
    private fun isNotConstraint(property: Property<*>) = property !is Constraint

    //endregion Task Properties Functions

    //region Property setters for chaining

    /**
     * Sets this Task's time Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `timeProperty` is after now and it is a Constraint, otherwise
     * no more changes will occur.
     *
     * In the case that the passed in `timeProperty` is a Constraint and it is after now, three things will happen:
     * <ul>
     *     <li>This Task's state will become SLEEPING</li>
     *     <li>This Task will become failable if it wasn't already</li>
     *     <li>This Task will start checking the time, and will become EXISTING once the time in `timeProperty` has
     *     passed and will also make the time Constraint MET if it wasn't already see [timeConstraintTimeChecking()]
     *     </li>
     * </ul>
     *
     * If the passed in `timeProperty` is not a Constraint or is not after now then the Task's state will remain the
     * same.
     *
     * @see Task.timeConstraintTimeChecking
     * @param timeProperty the `Property` of type `Time` that this Task's time will be set to
     * @return this Task after setting the Task's time Property
     */
    fun setTimeProperty(timeProperty: Property<Time>): Task {
        this.time = timeProperty
        if (timeProperty.value.isAfter(now()) && timeProperty is Constraint) {
            this.state = TaskState.SLEEPING
            makeFailableIfConstraint(timeProperty)
            timeConstraintTimeChecking()
        }
        return this
    }

    /**
     * Sets this Task's time Constraint.
     *
     * @see Task.setTimeProperty
     * @param timeConstraint the `Constraint` of type `Time` that this Task's time will be set to
     * @return this Task after setting the Task's time Constraint
     */
    fun setTimeConstraint(timeConstraint: Constraint<Time>): Task {
        return setTimeProperty(timeConstraint)
    }

    /**
     * Sets this Task's time Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setTimeProperty(Property(SHOWING, myTime))`.
     *
     * @see Task.setTimeProperty
     * @param time the Time value that this Task's time value will be set to
     * @return this Task after setting the Task's time Property
     */
    fun setTimePropertyValue(time: Time): Task {
        return setTimeProperty(Property(SHOWING, time))
    }

    /**
     * Sets this Task's time Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setTimeConstraint(Constraint(SHOWING, myTime, UNMET))`.
     *
     * @see Task.setTimeProperty
     * @param time the Time value that this Task's time value will be set to
     * @return this Task after setting the Task's time Constraint
     */
    fun setTimeConstraintValue(time: Time): Task {
        return setTimeProperty(Constraint(SHOWING, time, UNMET))
    }

    /**
     * Sets this Task's duration Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `durationProperty` is a Constraint.
     *
     * In the case that the passed in `durationProperty` is a Constraint, two things will happen:
     * <ul>
     *     <li>This Task will become failable if it wasn't already</li>
     *     <li>This Task will start checking the time and after the duration has passed will make the duration
     *     Constraint MET if it wasn't already see [durationConstraintTimeChecking()]</li>
     * </ul>
     *
     * If the passed in `durationProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.durationConstraintTimeChecking
     * @param durationProperty the `Property` of type `java.time.Duration` that this Task's duration will be set to
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationProperty(durationProperty: Property<Duration>): Task {
        this.duration = durationProperty
        timeDurationSet = now()
        if (durationProperty is Constraint) {
            makeFailableIfConstraint(durationProperty)
            durationConstraintTimeChecking()
        }
        return this
    }

    /**
     * Gets this Task's duration left until the duration Constraint will be met.
     *
     * This is not necessarily only used for Constraints but is more useful for when duration is a Constraint, since
     * this will return the difference in time between now and the time the duration is due to finish, this does not
     * require duration to be a Constraint but is of not much interest if duration is not a Constraint.
     *
     * @return the Duration left until this Task's duration Constraint is met
     * @throws IllegalStateException if the Duration has not been set
     */
    fun getDurationLeft(): Duration {
        if (duration.value == DEFAULT_DURATION) {
            throw IllegalStateException("Duration not set!")
        } else {
            val timeDue = timeDurationSet.plus(duration.value)
            return Duration.between(now(), timeDue)
        }
    }

    /**
     * Sets this Task's duration Constraint.
     *
     * @see Task.setDurationProperty
     * @param durationConstraint the `Constraint` of type `java.time.Duration` that this Task's duration will be set to
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraint(durationConstraint: Constraint<Duration>): Task {
        return setDurationProperty(durationConstraint)
    }

    /**
     * Sets this Task's duration Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDurationProperty(Property(SHOWING, myDuration))`.
     *
     * @see Task.setDurationProperty
     * @param duration the java.time.Duration value that this Task's duration value will be set to
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyValue(duration: Duration): Task {
        return setDurationProperty(Property(SHOWING, duration))
    }

    /**
     * Sets this Task's duration Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setDurationConstraint(Constraint(SHOWING, myDuration, UNMET))`.
     *
     * @see Task.setDurationProperty
     * @param duration the java.time.Duration value that this Task's duration value will be set to
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintValue(duration: Duration): Task {
        return setDurationProperty(Constraint(SHOWING, duration, UNMET))
    }

    /**
     * Sets this Task's duration Property with the duration of the TimeUnit multiplied by the `count` as the Property's
     * value and the `timeUnitProperty`'s `isVisible` value
     *
     * This allows to use Custom Time Units for setting the duration.
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnitProperty the Property of type `TimeUnit` that will be used to set this Task's duration
     * Property's visibility to and set the value to by multiplying by the `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyTimeUnits(timeUnitProperty: Property<TimeUnit>, count: Int): Task {
        val duration = TimeUnit.toJavaDuration(timeUnitProperty.value, count)
        if (timeUnitProperty is Constraint) {
            setDurationProperty(Constraint(timeUnitProperty.isVisible, duration, UNMET))
        } else setDurationProperty(Property(timeUnitProperty.isVisible, duration))

        return this
    }

    /**
     * Sets this Task's duration Constraint with the duration of the TimeUnit multiplied by the `count` as the
     * Constraint's value and the `timeUnitConstraint`'s Constraint values for this Task's duration Constraint values.
     *
     * This allows to use Custom Time Units for setting the duration.
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnitConstraint the Constraint of type `TimeUnit` that will be used to set this Task's duration
     * Constraint's visibility to and set the value to by multiplying by the `count` and this Task's duration's
     * `isMet` value to
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintTimeUnits(timeUnitConstraint: Constraint<TimeUnit>, count: Int): Task {
        val duration = TimeUnit.toJavaDuration(timeUnitConstraint.value, count)
        setDurationProperty(Constraint(timeUnitConstraint.isVisible, duration, timeUnitConstraint.isMet))
        return this
    }

    /**
     * Sets this Task's duration Property with the duration of the TimeUnit multiplied by the `count` as the Property's
     * value and makes the Property showing.
     *
     * This allows to use Custom Time Units for setting the duration and is shorthand for writing
     * `setDurationPropertyTimeUnits(Property(SHOWING, myTimeUnit), myCount)`
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnit the TimeUnit that will be used to set this Task's duration to by multiplying it by the
     * `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyTimeUnitsValue(timeUnit: TimeUnit, count: Int): Task {
        return setDurationProperty(Property(SHOWING, TimeUnit.toJavaDuration(timeUnit, count)))
    }

    /**
     * Sets this Task's duration Constraint with the duration of the TimeUnit multiplied by the `count` as the
     * Constraints's value and makes the Constraint showing and unmet.
     *
     * This allows to use Custom Time Units for setting the duration and is shorthand for writing
     * `setDurationConstraintTimeUnits(Constraint(SHOWING, myTimeUnit, UNMET), myCount)`
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnit the TimeUnit that will be used to set this Task's duration to by multiplying it by the
     * `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintTimeUnitsValue(timeUnit: TimeUnit, count: Int): Task {
        return setDurationProperty(Constraint(SHOWING, TimeUnit.toJavaDuration(timeUnit, count), UNMET))
    }

    /**
     * Sets this Task's priority Property.
     *
     * Priority is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for priority.
     *
     * @see Priority
     * @param priorityProperty the `Property` of type `Priority` that this Task's priority will be set to
     * @return this Task after setting the Task's priority Property
     */
    fun setPriorityProperty(priorityProperty: Property<Priority>): Task {
        this.priority = Property(priorityProperty.isVisible, priorityProperty.value)
        return this
    }

    /**
     * Sets this Task's priority Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setPriorityProperty(Property(SHOWING, myPriority))`.
     *
     * @see Task.setPriorityProperty
     * @param priority the Priority value that this Task's priority value will be set to
     * @return this Task after setting the Task's priority Property
     */
    fun setPriorityValue(priority: Priority): Task {
        return setPriorityProperty(Property(SHOWING, priority))
    }

    /**
     * Sets this Task's labels Property.
     *
     * Label is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for labels.
     *
     * @see Label
     * @param labelProperty the `Property` containing the list of all labels that this Task's labels property will be
     * set to
     * @return this Task after setting the Task's labels Property
     */
    fun setLabelProperty(labelProperty: Property<ArrayList<Label>>): Task {
        this.labels = Property(labelProperty.isVisible, labelProperty.value)
        return this
    }

    /**
     * Sets this Task's labels Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setLabelProperty(Property(SHOWING, myLabelList))`.
     *
     * @see Task.setLabelProperty
     * @param labels the list of labels that this Task's labels Property will be set to
     * @return this Task after setting the Task's labels Property
     */
    fun setLabelValue(vararg labels: Label): Task {
        return setLabelProperty(Property(SHOWING, arrayListOf(*labels)))
    }

    /**
     * Adds a label to this Task's labels Property and makes this Task's labels Property showing if it wasn't already.
     *
     * @see Label
     * @param label the label to add to this Task's labels Property
     * @return this Task after adding the label to the Task's labels Property
     */
    fun addLabel(label: Label): Task {
        if (!this.labels.isVisible) {
            this.labels.isVisible = SHOWING
        }
        this.labels.value.add(label)
        return this
    }

    /**
     * Removes a label from this Task's labels Property.
     *
     * @see Label
     * @param label the label to remove from this Task's labels Property
     * @return this Task after removing the label from the Task's labels Property
     */
    fun removeLabel(label: Label): Task {
        this.labels.value.remove(label)
        return this
    }

    /**
     * Sets this Task's optional Property.
     *
     * Optional is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for optional.
     *
     * @param optionalProperty the `Property` of type `Optional` that this Task's optional will be set to
     * @return this Task after setting the Task's optional Property
     */
    fun setOptionalProperty(optionalProperty: Property<Optional>): Task {
        this.optional = Property(optionalProperty.isVisible, optionalProperty.value)
        return this
    }

    /**
     * Sets this Task's optional Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setOptionalProperty(Property(SHOWING, myOptional))`.
     *
     * @see Task.setOptionalProperty
     * @param optional the Optional value that this Task's optional value will be set to
     * @return this Task after setting the Task's optional Property
     */
    fun setOptionalValue(optional: Optional): Task {
        return setOptionalProperty(Property(SHOWING, optional))
    }

    /**
     * Sets this Task's description Property.
     *
     * Description is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for description.
     *
     * @see StringBuilder
     * @param descriptionProperty the `Property` containing the description that this Task's description property
     * will be set to
     * @return this Task after setting the Task's description Property
     */
    fun setDescriptionProperty(descriptionProperty: Property<Description>): Task {
        this.description = Property(descriptionProperty.isVisible, descriptionProperty.value)
        return this
    }

    /**
     * Sets this Task's description Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDescriptionProperty(Property(SHOWING, myDescription))`.
     *
     * @see Task.setDescriptionProperty
     * @param description the description that this Task's description Property will be set to
     * @return this Task after setting the Task's description Property
     */
    fun setDescriptionValue(description: Description): Task {
        return setDescriptionProperty(Property(SHOWING, description))
    }

    /**
     * Sets this Task's checklist Property, the passed in Property can be a Constraint.
     *
     * If the passed in `checklistProperty` is a Constraint then this Task will become failable if it wasn't already
     * and will start viewing the checklist to see if all its list items are checked, if they are, the checklist
     * Constraint is met. This also refers to empty checklists, meaning to this Task, an empty checklist is one that
     * has all its items checked and so the checklist Constraint is met, thus it is important to differentiate
     * between the case that the checklist contains unchecked items or is just empty, this is up to the
     * implementation to deal with.
     *
     * @see Task.checklistConstraintChecking
     * @see Checklist
     * @param checklistProperty the `Property` of type `Checklist` that this Task's checklist will be set to
     * @return this Task after setting the Task's checklist Property
     */
    fun setChecklistProperty(checklistProperty: Property<Checklist>): Task {
        this.checklist = checklistProperty
        if (checklistProperty is Constraint) {
            makeFailableIfConstraint(checklistProperty)
            checklistConstraintChecking()
        }
        return this
    }

    /**
     * Sets this Task's checklist Constraint.
     *
     * @see Task.setChecklistProperty
     * @param checklistConstraint the `Constraint` of type `Checklist` that this Task's checklist will be set to
     * @return this Task after setting the Task's checklist Constraint
     */
    fun setChecklistConstraint(checklistConstraint: Constraint<Checklist>): Task {
        return setChecklistProperty(checklistConstraint)
    }

    /**
     * Sets this Task's checklist Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setChecklistProperty(Property(SHOWING, myChecklist))`.
     *
     * @see Task.setChecklistProperty
     * @param checklist the Checklist value that this Task's checklist value will be set to
     * @return this Task after setting the Task's checklist Property
     */
    fun setChecklistPropertyValue(checklist: Checklist): Task {
        return setChecklistProperty(Property(SHOWING, checklist))
    }

    /**
     * Sets this Task's checklist Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setChecklistConstraint(Constraint(SHOWING, myChecklist, UNMET))`.
     *
     * @see Task.setChecklistProperty
     * @param checklist the Checklist value that this Task's checklist value will be set to
     * @return this Task after setting the Task's checklist Constraint
     */
    fun setChecklistConstraintValue(checklist: Checklist): Task {
        return setChecklistProperty(Constraint(SHOWING, checklist, UNMET))
    }

    /**
     * Sets this Task's deadline Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `deadlineProperty` is a Constraint.
     *
     * In the case that the passed in `deadlineProperty` is a Constraint, three things will happen:
     * <ul>
     *     <li>The deadline Constraint will become met until that deadline time where it will become unmet again,
     *     this is only in the case that the Task is not killed before the deadline, this is done in order to allow
     *     the Task to be killed </li>
     *     <li>This Task will become failable if it wasn't already</li>
     *     <li>This Task will start checking the time to compare it with the deadline, if the current time is after
     *     the deadline plus the defined grace period [GRACE_PERIOD] then the Task becomes failed and the deadline
     *     Constraint becomes unmet. See [deadlineConstraintChecking()].
     *     </li>
     * </ul>
     *
     * If the passed in `deadlineProperty` is not a Constraint then there will be no further changes and the Task
     * will not fail automatically.
     *
     * @see Task.deadlineConstraintChecking
     * @param deadlineProperty the `Property` of type `java.time.LocalDateTime` that this Task's deadline will be set to
     * @return this Task after setting the Task's deadline Property
     */
    fun setDeadlineProperty(deadlineProperty: Property<Time>): Task {
        this.deadline = deadlineProperty
        if (deadlineProperty is Constraint) {
            makeFailableIfConstraint(deadlineProperty)
            deadlineConstraintChecking()
        }
        return this
    }

    /**
     * Gets the duration left until this Task's deadline will occur, this ignores the grace period.
     *
     * @return the Duration left until this Task's deadline occurs, ignores the grace period
     * @throws IllegalStateException if the deadline has not been set
     */
    fun getTimeUntilDeadline(): Duration {
        if (deadline.value == DEFAULT_DEADLINE) {
            throw IllegalStateException("Deadline not set!")
        } else {
            return Duration.between(now(), this.deadline.value)
        }
    }

    /**
     * Sets this Task's deadline Constraint.
     *
     * @see Task.setDeadlineProperty
     * @param deadlineConstraint the `Constraint` of type `java.time.LocalDateTime` that this Task's deadline will be
     * set to
     * @return this Task after setting the Task's deadline Constraint
     */
    fun setDeadlineConstraint(deadlineConstraint: Constraint<Time>): Task {
        return setDeadlineProperty(deadlineConstraint)
    }

    /**
     * Sets this Task's deadline Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDeadlineProperty(Property(SHOWING, myDeadline))`.
     *
     * @see Task.setDeadlineProperty
     * @param deadline the java.time.LocalDateTime value that this Task's deadline value will be set to
     * @return this Task after setting the Task's deadline Property
     */
    fun setDeadlinePropertyValue(deadline: Time): Task {
        return setDeadlineProperty(Property(SHOWING, deadline))
    }

    /**
     * Sets this Task's deadline Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setDeadlineConstraint(Constraint(SHOWING, myDeadline, UNMET))`.
     *
     * @see Task.setDeadlineProperty
     * @param deadline the java.time.LocalDateTime value that this Task's deadline value will be set to
     * @return this Task after setting the Task's deadline Constraint
     */
    fun setDeadlineConstraintValue(deadline: Time): Task {
        return setDeadlineProperty(Constraint(SHOWING, deadline, UNMET))
    }

    fun setTargetProperty(targetProperty: Property<Target>): Task {
        this.target = targetProperty
        makeFailableIfConstraint(targetProperty)
        return this
    }

    fun setTargetConstraint(targetConstraint: Constraint<Target>): Task {
        return setTargetProperty(targetConstraint)
    }

    fun setTargetValue(target: Target): Task {
        return setTargetProperty(Property(SHOWING, target))
    }

    fun setBeforeProperty(beforeProperty: Property<Long>): Task {
        this.before = beforeProperty
        makeFailableIfConstraint(beforeProperty)
        return this
    }

    fun setBeforeProperty(beforeTask: Task): Task {
        return setBeforeProperty(Property(SHOWING, beforeTask.taskID))
    }

    fun setBeforeConstraint(beforeConstraint: Constraint<Long>): Task {
        return setBeforeProperty(beforeConstraint)
    }

    fun setBeforeConstraint(beforeTask: Task): Task {
        return setBeforeProperty(Constraint(SHOWING, beforeTask.taskID, UNMET))
    }

    fun setBeforeValue(before: Long): Task {
        return setBeforeProperty(Property(SHOWING, before))
    }

    fun setAfterProperty(afterProperty: Property<Long>): Task {
        this.after = afterProperty
        makeFailableIfConstraint(afterProperty)
        return this
    }

    fun setAfterProperty(afterTask: Task): Task {
        return setAfterProperty(Property(SHOWING, afterTask.taskID))
    }

    fun setAfterConstraint(afterConstraint: Constraint<Long>): Task {
        return setAfterProperty(afterConstraint)
    }

    fun setAfterConstraint(afterTask: Task): Task {
        return setAfterProperty(Constraint(SHOWING, afterTask.taskID, UNMET))
    }

    fun setAfterValue(after: Long): Task {
        return setAfterProperty(Property(SHOWING, after))
    }

    //endregion Property setters for chaining

    //region Hide Properties

    fun hideTime() {
        if (isNotConstraint(time)) {
            time = DEFAULT_TIME_PROPERTY
        } else throw IllegalStateException("Cannot hide, time is Constraint")
    }

    fun hideDuration() {
        if (isNotConstraint(duration)) {
            duration = DEFAULT_DURATION_PROPERTY
        } else throw IllegalStateException("Cannot hide, duration is Constraint")
    }

    fun hidePriority() {
        if (isNotConstraint(priority)) {
            priority = DEFAULT_PRIORITY_PROPERTY
        } else throw IllegalStateException("Cannot hide, priority is Constraint")
    }

    fun hideLabel() {
        if (isNotConstraint(labels)) {
            labels = DEFAULT_LABEL_PROPERTY
        } else throw IllegalStateException("Cannot hide, labels is Constraint")
    }

    fun hideOptional() {
        if (isNotConstraint(optional)) {
            optional = DEFAULT_OPTIONAL_PROPERTY
        } else throw IllegalStateException("Cannot hide, optional is Constraint")
    }

    fun hideDescription() {
        if (isNotConstraint(description)) {
            description = DEFAULT_DESCRIPTION_PROPERTY
        } else throw IllegalStateException("Cannot hide, description is Constraint")
    }

    fun hideChecklist() {
        if (isNotConstraint(checklist)) {
            checklist = DEFAULT_CHECKLIST_PROPERTY
        } else throw IllegalStateException("Cannot hide, checklist is Constraint")
    }

    fun hideDeadline() {
        if (isNotConstraint(deadline)) {
            deadline = DEFAULT_DEADLINE_PROPERTY
        } else throw IllegalStateException("Cannot hide, deadline is Constraint")
    }

    fun hideTarget() {
        if (isNotConstraint(target)) {
            target = DEFAULT_TARGET_PROPERTY
        } else throw IllegalStateException("Cannot hide, target is Constraint")
    }

    fun hideBefore() {
        if (isNotConstraint(before)) {
            before = DEFAULT_BEFORE_PROPERTY
        } else throw IllegalStateException("Cannot hide, before is Constraint")
    }

    fun hideAfter() {
        if (isNotConstraint(after)) {
            after = DEFAULT_AFTER_PROPERTY
        } else throw IllegalStateException("Cannot hide, after is Constraint")
    }

    //endregion Hide Properties

    //region Task lifecycle

    fun getTaskState() = state

    private fun isExisting() = state == TaskState.EXISTING

    fun canKill() = isKillable &&
            isExisting() &&
            getAllUnmetAndShowingConstraints().isEmpty()


    fun canFail() = isFailable &&
            isExisting()

    fun canSleep() = getTaskState() == TaskState.FAILED

    fun fail() {
        if (state == TaskState.FAILED) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is already Failed!", getTaskState())
        }
        if (!isFailable) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is not Failable", getTaskState())
        } else if (canFail()) {
            state = TaskState.FAILED
            age++
            failedTimes.add(now())
        } else {
            throw TaskStateException("Fail unsuccessful, unknown reason, remember only EXISTING tasks can be failed!", getTaskState())
        }
    }

    fun sleep() {
        if (state == TaskState.SLEEPING) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is already Sleeping!", getTaskState())
        }
        if (state == TaskState.KILLED) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is Killed!", getTaskState())
        }
        if (state == TaskState.EXISTING) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is Existing!", getTaskState())
        } else if (canSleep()) {
            state = TaskState.SLEEPING
        } else {
            throw TaskStateException("Sleep unsuccessful, unknown reason, remember only FAILED tasks can be slept!", getTaskState())
        }
    }

    // Send this tasks info to create a template from it
    fun sendToTemplate() {

    }


    // If a Task is killed it can be modified because it doesn't matter at all, after killed there is no other State.
    //TODO This isn't entirely true! We need to do something to make sure that Killed Tasks can't be meddled with much
    fun kill() {
        if (state == TaskState.KILLED) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is already Killed!", getTaskState())
        }
        if (!isKillable) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is not Killable", getTaskState())
        }
        if (state == TaskState.FAILED) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is FAILED", getTaskState())
        }
        if (!getAllUnmetAndShowingConstraints().isEmpty()) {
            throw TaskStateException("Kill unsuccessful, ${this.title} has unmet Constraints", getTaskState())
        } else if (canKill()) {
            state = TaskState.KILLED
            killedTime = now()
        } else {
            throw TaskStateException("Kill unsuccessful, unknown reason, remember only EXISTING tasks can be killed!", getTaskState())
        }
    }

    private fun killed() = state == TaskState.KILLED

    //endregion Task lifecycle

    //region Concurrency

    /**
     * Checks the time on the `stateCheckingThread` to match it with this Task's time Constraint value.
     *
     * When the time is past this Task's time Constraint value the state will change to EXISTING and the time
     * Constraint will be met if it wasn't already and the checking ends.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `time` is set as a Constraint and the time value is in the future.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons
     */
    private fun timeConstraintTimeChecking() {
        var done = false
        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .subscribeOn(Concurrent.stateCheckingThread)
                .subscribe(
                        {
                            if (now().isAfter(this.time.value)) {
                                this.state = TaskState.EXISTING
                                if (this.time is Constraint && (this.time as Constraint).isMet != MET) {
                                    (this.time as Constraint).isMet = MET
                                }
                                done = true
                            }
                        },
                        {
                            throw ConcurrentException("Time Constraint time checking failed!")
                        }
                )
    }

    /**
     * Checks the time that this Task's duration will end on the `stateCheckingThread` to match it with this Task's
     * duration Constraint value
     *
     * When the time is past this Task's duration Constraint value the duration Constraint will be met if it wasn't
     * already and the checking ends.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `duration` is set as a Constraint.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons
     */
    private fun durationConstraintTimeChecking() {
        var done = false
        val minimumTime = now().plus(this.duration.value)
        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .subscribeOn(Concurrent.stateCheckingThread)
                .subscribe(
                        {
                            if (now().isAfter(minimumTime)) {
                                if (this.duration is Constraint && (this.duration as Constraint).isMet != MET) {
                                    (this.duration as Constraint).isMet = MET
                                }
                                done = true
                            }
                        },
                        {
                            throw ConcurrentException("Duration Constraint time checking failed!")
                        }
                )
    }

    /**
     * Checks this Task's checklist Property value (the actual checklist) on the `stateCheckingThread` to see if all
     * its list items are checked or not.
     *
     * When the checklist has no unchecked items this Task's checklist Constraint will be met if it wasn't already
     * and the checking ends.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `checklist` is set as a Constraint.
     *
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons
     */
    private fun checklistConstraintChecking() {
        var done = false
        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .subscribeOn(Concurrent.stateCheckingThread)
                .subscribe(
                        {
                            if (this.checklist.value.getAllUncheckedItems().isEmpty()) {
                                if (this.checklist is Constraint && (this.checklist as Constraint).isMet != MET) {
                                    (this.checklist as Constraint).isMet = MET
                                }
                                done = true
                            }
                        },
                        {
                            throw ConcurrentException("Checklist Constraint checking failed")
                        }
                )
    }

    /**
     * Checks the time on the `stateCheckingThread` to match it with this Task's deadline Constraint value plus the
     * grace period [GRACE_PERIOD].
     *
     * When the time is past this Task's deadline Constraint value plus the grace period, the state will change to
     * FAILED and the deadline Constraint will be unmet and the checking ends.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `deadline` is set as a Constraint.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons
     */
    private fun deadlineConstraintChecking() {
        var done = false
        val deadline0 = this.deadline.value.plus(GRACE_PERIOD)
        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .doOnSubscribe { (deadline as Constraint).isMet = true }
                .subscribeOn(Concurrent.stateCheckingThread)
                .subscribe(
                        {
                            if (now().isAfter(deadline0)) {
                                if (canFail()) {
                                    this.fail()
                                    (deadline as Constraint).isMet = false
                                }
                                done = true
                            }
                        },
                        {
                            throw ConcurrentException("Deadline Constraint checking failed!")
                        }
                )

    }

    //endregion Concurrency

    //region Overriden from kotlin.Any

    override fun hashCode() =
            title.hashCode() + getAllShowingProperties().hashCode()

    override fun equals(other: Any?) =
            other is Task &&
                    other.title == this.title &&
                    other.getTaskState() == this.state &&
                    other.getAllShowingProperties() == this.getAllShowingProperties()

    override fun toString(): String {
        val result = StringBuilder("$title\n")
        result.append("ID: $taskID isKillable: $isKillable isFailable: $isFailable state: $state\n")

        result.append("\tP:\n")

        getAllShowingProperties().filter { it !is Constraint }.forEach { result.append("\t\t$it\n") }

        result.append("\tC:\n")

        getAllShowingConstraints().forEach { result.append("\t\t$it\n") }

        return result.toString()
    }

    //endregion Overriden from kotlin.Any
}


