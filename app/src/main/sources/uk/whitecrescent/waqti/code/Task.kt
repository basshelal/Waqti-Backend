package uk.whitecrescent.waqti.code

import io.reactivex.Observable
import java.time.Duration
import java.time.LocalDateTime
import java.util.Random

class Task(var title: String) {

    //region Class Properties

    //TODO update KDoc

    /**
     * The Task State is the state in which the task is in at this point in time.
     * By default this is set to EXISTING.
     * See The Task Lifecycle Documentation for more information
     * @see TaskState
     */
    private var state = DEFAULT_TASK_STATE

    /**
     * Boolean value representing whether it is possible for this Task to be failed at any arbitrary point in time.
     * Note that this is not the same as whether it can be failed right now, however if a Task's `isFailable`
     * is `false` then it can not be failed at this point in time.
     * @see TaskState
     * @see Constraint
     */
    var isFailable = false

    /**
     * Boolean value representing whether it is possible for this Task to be killed at any arbitrary point in time.
     * Note that this is not the same as whether it can be killed right now, however if a Task's `isKillable`
     * is `false` then it can not be killed at this point in time.
     * @see TaskState
     */
    var isKillable = true

    /**
     * A Long value representing an ID for a Task.
     * Every Task has a unique identifier which is generated by means of pseudo-random number designation.
     * No 2 Tasks can have the same taskID, all taskIDs are positive Long values generated randomly.
     * The list of all currently used IDs should be stored persistently.
     * @see GSON.newID
     * @see java.util.Random.nextLong
     */
    var taskID = Math.abs(Random().nextLong())

    // The point in time at which the duration Property was set, used to calculate duration left
    private var timeDurationSet = DEFAULT_TIME

    // A Task ages when it is failed
    var age = 0

    // The times a task has been failed
    var failedTimes = arrayListOf<Time>()

    // The time a task is killed
    var killedTime = Time.MIN

    //endregion

    //region Task Properties

    /**
     * The point in natural time after which this Task will be relevant, this can also be referred to as scheduled
     * time.
     *
     * If time is a Constraint then the Task cannot be killed until after that time
     * and is in the SLEEPING state during that period, however, if time is not a Constraint then the Task can be
     * killed freely and will be in its previous state meaning no lifecycle change will be made. If time is a
     * Property then it has no rules on killing the Task.
     *
     * @see LocalDateTime
     */
    var time: Property<Time> = DEFAULT_TIME_PROPERTY
        private set(time) {
            field = time
        }

    /**
     * The estimated amount of time that this Task will take, this can also be referred to as minimum duration.
     *
     * This is defined in any Time Measurement Unit, either as a standard Time Unit such as seconds or days etc or
     * custom Time Units [TimeUnit]. This can also be referred to as minimum duration. If duration is a Constraint
     * then the Task cannot be killed in the midst of the duration, it can be killed only after it has ended. If
     * duration is a Property then it has no rules on killing the Task.
     *
     * @see Duration
     * @see TimeUnit
     */
    var duration: Property<Duration> = DEFAULT_DURATION_PROPERTY
        private set(duration) {
            field = duration
        }

    /**
     * The user defined level of importance of a Task represented as a String with a number representing importance
     * level.
     *
     * Priority is particularly useful in solving or mediating Task collisions within collections. A Task collision
     * occurs when two or more Tasks in a collection share the same time, if they have different priority levels then
     * the Task with the higher priority level will be shown and a collision warning will be displayed to the user,
     * this is called a weak collision. If the tasks have equal priority levels then the user must mediate or solve
     * the collision themselves, this is called a strong collision.
     *
     * Priority can not be a Constraint.
     *
     * @see Priority
     */
    var priority: Property<Priority> = DEFAULT_PRIORITY_PROPERTY
        private set(priority) {
            field = priority
        }

    //TODO this should be many labels, not 1 ! So an ArrayList of Labels
    var label: Property<Label> = DEFAULT_LABEL_PROPERTY
        private set(label) {
            field = label
        }

    var optional: Property<Optional> = DEFAULT_OPTIONAL_PROPERTY
        private set(optional) {
            field = optional
        }

    var description: Property<Description> = DEFAULT_DESCRIPTION_PROPERTY
        private set(description) {
            field = description
        }

    var checklist: Property<Checklist> = DEFAULT_CHECKLIST_PROPERTY
        private set(checklist) {
            field = checklist
        }

    var deadline: Property<Time> = DEFAULT_DEADLINE_PROPERTY
        private set(deadline) {
            field = deadline
        }

    var target: Property<String> = DEFAULT_TARGET_PROPERTY
        private set(target) {
            field = target
        }

    // The Task before this
    var before: Property<TaskID> = DEFAULT_BEFORE_PROPERTY
        private set(before) {
            field = before
        }

    // The Task after this
    var after: Property<TaskID> = DEFAULT_AFTER_PROPERTY
        private set(after) {
            field = after
        }

    //TODO Implement this guy everywhere please but define him in the .md
    var subTasks: Property<ArrayList<TaskID>> = DEFAULT_SUB_TASKS_PROPERTY
        private set(subTasks) {
            field = subTasks
        }


    //endregion

    //region Task Properties Functions

    private fun makeFailableIfConstraint(property: Property<*>) {
        if (!this.isFailable && property is Constraint) {
            this.isFailable = true
        }
    }

    private fun getAllProperties() = listOf(
            time,
            duration,
            priority,
            label,
            optional,
            description,
            checklist,
            deadline,
            target,
            before,
            after
    )

    private fun getAllConstraints() = getAllProperties().filter { it is Constraint }

    fun getAllShowingProperties() =
            getAllProperties().filter { it.isVisible }

    fun getAllShowingConstraints() =
            getAllConstraints().filter { it.isVisible }

    fun getAllUnmetAndShowingConstraints() =
            getAllConstraints().filter { !(it as Constraint).isMet && it.isVisible }

    private fun isNotConstraint(property: Property<*>) = property !is Constraint

    //endregion

    //region Property setters for chaining

    /**
     * Sets this Task's time Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `timeProperty` is after now and it is a Constraint, otherwise
     * no more changes will occur.
     *
     * In the case that the passed in `timeProperty` is a Constraint and it is after now, three things will happen:
     * <ul>
     *     <li>This Task's state will become SLEEPING</li>
     *     <li>This Task will become failable if it wasn't already</li>
     *     <li>This Task will start checking the time, and will become EXISTING once the time in `timeProperty` has
     *     passed and will also make the time Constraint MET if it wasn't already see [timeConstraintTimeChecking()]
     *     </li>
     * </ul>
     *
     * If the passed in `timeProperty` is not a Constraint or is not after now then the Task's state will remain the
     * same.
     *
     * @see Task.timeConstraintTimeChecking
     * @param timeProperty the `Property` of type `Time` that this Task's time will be set to
     * @return this Task after setting the Task's time Property
     */
    fun setTimeProperty(timeProperty: Property<Time>): Task {
        this.time = timeProperty
        if (timeProperty.value.isAfter(now()) && timeProperty is Constraint) {
            this.state = TaskState.SLEEPING
            makeFailableIfConstraint(timeProperty)
            timeConstraintTimeChecking()
        }
        return this
    }

    /**
     * Sets this Task's time Constraint.
     *
     * @see Task.setTimeProperty
     * @param timeConstraint the `Constraint` of type `Time` that this Task's time will be set to
     * @return this Task after setting the Task's time Constraint
     */
    fun setTimeConstraint(timeConstraint: Constraint<Time>): Task {
        return setTimeProperty(timeConstraint)
    }

    /**
     * Sets this Task's time Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setTimeProperty(Property(SHOWING, myTime))`.
     *
     * @see Task.setTimeProperty
     * @param time the Time value that this Task's time value will be set to
     * @return this Task after setting the Task's time Property
     */
    fun setTimePropertyValue(time: Time): Task {
        return setTimeProperty(Property(SHOWING, time))
    }

    /**
     * Sets this Task's time Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setTimeConstraint(Constraint(SHOWING, myTime, UNMET))`.
     *
     * @see Task.setTimeProperty
     * @param time the Time value that this Task's time value will be set to
     * @return this Task after setting the Task's time Constraint
     */
    fun setTimeConstraintValue(time: Time): Task {
        return setTimeProperty(Constraint(SHOWING, time, UNMET))
    }

    /**
     * Sets this Task's duration Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `durationProperty` is a Constraint.
     *
     * In the case that the passed in `durationProperty` is a Constraint, two things will happen:
     * <ul>
     *     <li>This Task will become failable if it wasn't already</li>
     *     <li>This Task will start checking the time and after the duration has passed will make the duration
     *     Constraint MET if it wasn't already see [durationConstraintTimeChecking()]</li>
     * </ul>
     *
     * If the passed in `durationProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.durationConstraintTimeChecking
     * @param durationProperty the `Property` of type `java.time.Duration` that this Task's duration will be set to
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationProperty(durationProperty: Property<Duration>): Task {
        this.duration = durationProperty
        timeDurationSet = now()
        if (durationProperty is Constraint) {
            makeFailableIfConstraint(durationProperty)
            durationConstraintTimeChecking()
        }
        return this
    }

    /**
     * Gets this Task's duration left until the duration Constraint will be met.
     *
     * This is not necessarily only used for Constraints but is more useful for when duration is a Constraint, since
     * this will return the difference in time between now and the time the duration is due to finish, this does not
     * require duration to be a Constraint but is of not much interest if duration is not a Constraint.
     *
     * @return the Duration left until this Task's duration Constraint is met
     * @throws IllegalStateException if the Duration has not been set
     */
    fun getDurationLeft(): Duration {
        if (duration.value == DEFAULT_DURATION) {
            throw IllegalStateException("Duration not set!")
        } else {
            val timeDue = timeDurationSet.plus(duration.value)
            return Duration.between(now(), timeDue)
        }
    }

    /**
     * Sets this Task's duration Constraint.
     *
     * @see Task.setDurationProperty
     * @param durationConstraint the `Constraint` of type `java.time.Duration` that this Task's duration will be set to
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraint(durationConstraint: Constraint<Duration>): Task {
        return setDurationProperty(durationConstraint)
    }

    /**
     * Sets this Task's duration Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDurationProperty(Property(SHOWING, myDuration))`.
     *
     * @see Task.setDurationProperty
     * @param duration the java.time.Duration value that this Task's duration value will be set to
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyValue(duration: Duration): Task {
        return setDurationProperty(Property(SHOWING, duration))
    }

    /**
     * Sets this Task's duration Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setDurationConstraint(Constraint(SHOWING, myDuration, UNMET))`.
     *
     * @see Task.setDurationProperty
     * @param duration the java.time.Duration value that this Task's duration value will be set to
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintValue(duration: Duration): Task {
        return setDurationProperty(Constraint(SHOWING, duration, UNMET))
    }

    /**
     * Sets this Task's duration Property with the duration of the TimeUnit multiplied by the `count` as the Property's
     * value and the `timeUnitProperty`'s `isVisible` value
     *
     * This allows to use Custom Time Units for setting the duration.
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnitProperty the Property of type `TimeUnit` that will be used to set this Task's duration
     * Property's visibility to and set the value to by multiplying by the `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyTimeUnits(timeUnitProperty: Property<TimeUnit>, count: Int): Task {
        val duration = TimeUnit.toJavaDuration(timeUnitProperty.value, count)
        if (timeUnitProperty is Constraint) {
            setDurationProperty(Constraint(timeUnitProperty.isVisible, duration, UNMET))
        } else setDurationProperty(Property(timeUnitProperty.isVisible, duration))

        return this
    }

    /**
     * Sets this Task's duration Constraint with the duration of the TimeUnit multiplied by the `count` as the
     * Constraint's value and the `timeUnitConstraint`'s Constraint values for this Task's duration Constraint values.
     *
     * This allows to use Custom Time Units for setting the duration.
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnitConstraint the Constraint of type `TimeUnit` that will be used to set this Task's duration
     * Constraint's visibility to and set the value to by multiplying by the `count` and this Task's duration's
     * `isMet` value to
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintTimeUnits(timeUnitConstraint: Constraint<TimeUnit>, count: Int): Task {
        val duration = TimeUnit.toJavaDuration(timeUnitConstraint.value, count)
        setDurationProperty(Constraint(timeUnitConstraint.isVisible, duration, timeUnitConstraint.isMet))
        return this
    }

    /**
     * Sets this Task's duration Property with the duration of the TimeUnit multiplied by the `count` as the Property's
     * value and makes the Property showing.
     *
     * This allows to use Custom Time Units for setting the duration and is shorthand for writing
     * `setDurationPropertyTimeUnits(Property(SHOWING, myTimeUnit), myCount)`
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnit the TimeUnit that will be used to set this Task's duration to by multiplying it by the
     * `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyTimeUnitsValue(timeUnit: TimeUnit, count: Int): Task {
        return setDurationProperty(Property(SHOWING, TimeUnit.toJavaDuration(timeUnit, count)))
    }

    /**
     * Sets this Task's duration Constraint with the duration of the TimeUnit multiplied by the `count` as the
     * Constraints's value and makes the Constraint showing and unmet.
     *
     * This allows to use Custom Time Units for setting the duration and is shorthand for writing
     * `setDurationConstraintTimeUnits(Constraint(SHOWING, myTimeUnit, UNMET), myCount)`
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnit the TimeUnit that will be used to set this Task's duration to by multiplying it by the
     * `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintTimeUnitsValue(timeUnit: TimeUnit, count: Int): Task {
        return setDurationProperty(Constraint(SHOWING, TimeUnit.toJavaDuration(timeUnit, count), UNMET))
    }

    /**
     * Sets this Task's priority Property.
     *
     * Priority is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for priority.
     *
     * @see Priority
     * @param priorityProperty the `Property` of type `Priority` that this Task's priority will be set to
     * @return this Task after setting the Task's priority Property
     */
    fun setPriorityProperty(priorityProperty: Property<Priority>): Task {
        this.priority = Property(priorityProperty.isVisible, priorityProperty.value)
        return this
    }

    /**
     * Sets this Task's priority Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setPriorityProperty(Property(SHOWING, myPriority))`.
     *
     * @see Task.setPriorityProperty
     * @param priority the Priority value that this Task's priority value will be set to
     * @return this Task after setting the Task's priority Property
     */
    fun setPriorityValue(priority: Priority): Task {
        return setPriorityProperty(Property(SHOWING, priority))
    }

    fun setLabelProperty(labelProperty: Property<Label>): Task {
        this.label = labelProperty
        makeFailableIfConstraint(labelProperty)
        return this
    }

    fun setLabelConstraint(labelConstraint: Constraint<Label>): Task {
        return setLabelProperty(labelConstraint)
    }

    fun setLabelValue(label: Label): Task {
        return setLabelProperty(Property(SHOWING, label))
    }

    fun setOptionalProperty(optionalProperty: Property<Boolean>): Task {
        this.optional = optionalProperty
        makeFailableIfConstraint(optionalProperty)
        return this
    }

    fun setOptionalConstraint(optionalConstraint: Constraint<Boolean>): Task {
        return setOptionalProperty(optionalConstraint)
    }

    fun setOptionalValue(optional: Boolean): Task {
        return setOptionalProperty(Property(SHOWING, optional))
    }

    fun setDescriptionProperty(descriptionProperty: Property<StringBuilder>): Task {
        this.description = descriptionProperty
        makeFailableIfConstraint(descriptionProperty)
        return this
    }

    fun setDescriptionConstraint(descriptionConstraint: Constraint<StringBuilder>): Task {
        return setDescriptionProperty(descriptionConstraint)
    }

    fun setDescriptionValue(description: StringBuilder): Task {
        return setDescriptionProperty(Property(SHOWING, description))
    }

    fun setChecklistProperty(checklistProperty: Property<Checklist>): Task {
        this.checklist = checklistProperty
        makeFailableIfConstraint(checklistProperty)
        return this
    }

    fun setChecklistConstraint(checklistConstraint: Constraint<Checklist>): Task {
        return setChecklistProperty(checklistConstraint)
    }

    fun setChecklistValue(checklist: Checklist): Task {
        return setChecklistProperty(Property(SHOWING, checklist))

    }

    fun setDeadlineProperty(deadlineProperty: Property<LocalDateTime>): Task {
        this.deadline = deadlineProperty
        if (deadlineProperty is Constraint) {
            concurrentTimeCheckingForDeadlineConstraint()
        }
        makeFailableIfConstraint(deadlineProperty)
        return this
    }

    fun setDeadlineConstraint(deadlineConstraint: Constraint<LocalDateTime>): Task {
        return setDeadlineProperty(deadlineConstraint)
    }

    fun setDeadlineValue(deadline: LocalDateTime): Task {
        return setDeadlineProperty(Property(SHOWING, deadline))
    }

    fun setTargetProperty(targetProperty: Property<String>): Task {
        this.target = targetProperty
        makeFailableIfConstraint(targetProperty)
        return this
    }

    fun setTargetConstraint(targetConstraint: Constraint<String>): Task {
        return setTargetProperty(targetConstraint)
    }

    fun setTargetValue(target: String): Task {
        return setTargetProperty(Property(SHOWING, target))
    }

    fun setBeforeProperty(beforeProperty: Property<Long>): Task {
        this.before = beforeProperty
        makeFailableIfConstraint(beforeProperty)
        return this
    }

    fun setBeforeProperty(beforeTask: Task): Task {
        return setBeforeProperty(Property(SHOWING, beforeTask.taskID))
    }

    fun setBeforeConstraint(beforeConstraint: Constraint<Long>): Task {
        return setBeforeProperty(beforeConstraint)
    }

    fun setBeforeConstraint(beforeTask: Task): Task {
        return setBeforeProperty(Constraint(SHOWING, beforeTask.taskID, UNMET))
    }

    fun setBeforeValue(before: Long): Task {
        return setBeforeProperty(Property(SHOWING, before))
    }

    fun setAfterProperty(afterProperty: Property<Long>): Task {
        this.after = afterProperty
        makeFailableIfConstraint(afterProperty)
        return this
    }

    fun setAfterProperty(afterTask: Task): Task {
        return setAfterProperty(Property(SHOWING, afterTask.taskID))
    }

    fun setAfterConstraint(afterConstraint: Constraint<Long>): Task {
        return setAfterProperty(afterConstraint)
    }

    fun setAfterConstraint(afterTask: Task): Task {
        return setAfterProperty(Constraint(SHOWING, afterTask.taskID, UNMET))
    }

    fun setAfterValue(after: Long): Task {
        return setAfterProperty(Property(SHOWING, after))
    }

    //endregion

    //region Hide Properties

    fun hideTime() {
        if (isNotConstraint(time)) {
            time = DEFAULT_TIME_PROPERTY
        } else throw IllegalStateException("Cannot hide, time is Constraint")
    }

    fun hideDuration() {
        if (isNotConstraint(duration)) {
            duration = DEFAULT_DURATION_PROPERTY
        } else throw IllegalStateException("Cannot hide, duration is Constraint")
    }

    fun hidePriority() {
        if (isNotConstraint(priority)) {
            priority = DEFAULT_PRIORITY_PROPERTY
        } else throw IllegalStateException("Cannot hide, priority is Constraint")
    }

    fun hideLabel() {
        if (isNotConstraint(label)) {
            label = DEFAULT_LABEL_PROPERTY
        } else throw IllegalStateException("Cannot hide, label is Constraint")
    }

    fun hideOptional() {
        if (isNotConstraint(optional)) {
            optional = DEFAULT_OPTIONAL_PROPERTY
        } else throw IllegalStateException("Cannot hide, optional is Constraint")
    }

    fun hideDescription() {
        if (isNotConstraint(description)) {
            description = DEFAULT_DESCRIPTION_PROPERTY
        } else throw IllegalStateException("Cannot hide, description is Constraint")
    }

    fun hideChecklist() {
        if (isNotConstraint(checklist)) {
            checklist = DEFAULT_CHECKLIST_PROPERTY
        } else throw IllegalStateException("Cannot hide, checklist is Constraint")
    }

    fun hideDeadline() {
        if (isNotConstraint(deadline)) {
            deadline = DEFAULT_DEADLINE_PROPERTY
        } else throw IllegalStateException("Cannot hide, deadline is Constraint")
    }

    fun hideTarget() {
        if (isNotConstraint(target)) {
            target = DEFAULT_TARGET_PROPERTY
        } else throw IllegalStateException("Cannot hide, target is Constraint")
    }

    fun hideBefore() {
        if (isNotConstraint(before)) {
            before = DEFAULT_BEFORE_PROPERTY
        } else throw IllegalStateException("Cannot hide, before is Constraint")
    }

    fun hideAfter() {
        if (isNotConstraint(after)) {
            after = DEFAULT_AFTER_PROPERTY
        } else throw IllegalStateException("Cannot hide, after is Constraint")
    }

    //endregion

    //region Task lifecycle

    fun getTaskState() = state

    private fun isExisting() = state == TaskState.EXISTING

    fun canKill() = isKillable &&
            isExisting() &&
            getAllUnmetAndShowingConstraints().isEmpty()


    fun canFail() = isFailable &&
            isExisting()

    fun canSleep() = getTaskState() == TaskState.FAILED

    fun fail() {
        if (state == TaskState.FAILED) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is already Failed!", getTaskState())
        }
        if (!isFailable) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is not Failable", getTaskState())
        } else if (canFail()) {
            state = TaskState.FAILED
            age++
            failedTimes.add(now())
        } else {
            throw TaskStateException("Fail unsuccessful, unknown reason, remember only EXISTING tasks can be failed!", getTaskState())
        }
    }

    fun sleep() {
        if (state == TaskState.SLEEPING) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is already Sleeping!", getTaskState())
        }
        if (state == TaskState.KILLED) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is Killed!", getTaskState())
        }
        if (state == TaskState.EXISTING) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is Existing!", getTaskState())
        } else if (canSleep()) {
            state = TaskState.SLEEPING
        } else {
            throw TaskStateException("Sleep unsuccessful, unknown reason, remember only FAILED tasks can be slept!", getTaskState())
        }
    }

    // Send this tasks info to create a template from it
    fun sendToTemplate() {

    }


    // If a Task is killed it can be modified because it doesn't matter at all, after killed there is no other State.
    //TODO This isn't entirely true! We need to do something to make sure that Killed Tasks can't be meddled with much
    fun kill() {
        if (state == TaskState.KILLED) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is already Killed!", getTaskState())
        }
        if (!isKillable) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is not Killable", getTaskState())
        }
        if (!getAllUnmetAndShowingConstraints().isEmpty()) {
            throw TaskStateException("Kill unsuccessful, ${this.title} has unmet Constraints", getTaskState())
        } else if (canKill()) {
            state = TaskState.KILLED
            killedTime = now()
        } else {
            throw TaskStateException("Kill unsuccessful, unknown reason, remember only EXISTING tasks can be killed!", getTaskState())
        }
    }

    private fun killed() = state == TaskState.KILLED

    //endregion

    //region Concurrency

    /**
     * Checks the time on the `stateCheckingThread` to match it with this Task's time Constraint value.
     *
     * When the time is past this Task's time Constraint value the state will change to EXISTING and the time
     * Constraint will be met if it wasn't already.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `time` is set as a Constraint and the time value is in the future.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons
     */
    private fun timeConstraintTimeChecking() {
        var done = false
        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .subscribeOn(Concurrent.stateCheckingThread)
                .subscribe(
                        {
                            if (now().isAfter(this.time.value)) {
                                this.state = TaskState.EXISTING
                                if (this.time is Constraint && (this.time as Constraint).isMet != MET) {
                                    (this.time as Constraint).isMet = MET
                                }
                                done = true
                            }
                        },
                        {
                            throw ConcurrentException("Time Constraint time checking failed!")
                        }
                )
    }

    /**
     * Checks the time that this Task's duration will end on the `stateCheckingThread` to match it with this Task's
     * duration Constraint value
     *
     * When the time is past this Task's duration Constraint value the duration Constraint will be met if it wasn't
     * already.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `duration` is set as a Constraint.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @throws ConcurrentException if the Observer's `onError` is called for any reasons
     */
    private fun durationConstraintTimeChecking() {
        var done = false
        val minimumTime = now().plus(this.duration.value)
        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .subscribeOn(Concurrent.stateCheckingThread)
                .subscribe(
                        {
                            if (now().isAfter(minimumTime)) {
                                if (this.duration is Constraint && (this.duration as Constraint).isMet != MET) {
                                    (this.duration as Constraint).isMet = MET
                                }
                                done = true
                            }
                        },
                        {
                            throw ConcurrentException("Duration Constraint time checking failed!")
                        }
                )
    }

    private fun concurrentTimeCheckingForDeadlineConstraint() {

        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { this.deadline.value.plusSeconds(1).isAfter(now()) }
                .subscribeOn(Concurrent.timeCheckingThread)
                .subscribe(
                        {
                            if (now().isAfter(this.deadline.value)) {
                                this.fail()
                            }
                        },
                        {
                            logE("Concurrent time checking for deadline failed!")
                            it.printStackTrace()
                        },
                        {
                            logI("Concurrent time checking for deadline completed!")
                        },
                        {
                            logI("Concurrent time checking for deadline started")
                        }
                )

    }

    //endregion


    //region Overriden from kotlin.Any

    override fun hashCode() =
            title.hashCode() + getAllShowingProperties().hashCode()

    override fun equals(other: Any?) =
            other is Task &&
                    other.title.equals(this.title) &&
                    other.getTaskState().equals(this.state) &&
                    other.getAllShowingProperties().equals(this.getAllShowingProperties())

    override fun toString(): String {
        val result = StringBuilder("$title\n")
        result.append("ID: ${this.taskID} isKillable: ${isKillable} isFailable: ${isFailable} state: ${state}\n")

        result.append("\tP:\n")

        getAllShowingProperties().filter { it !is Constraint }.forEach { result.append("\t\t$it\n") }

        result.append("\tC:\n")

        getAllShowingConstraints().forEach { result.append("\t\t$it\n") }

        return result.toString()
    }

    //endregion
}


